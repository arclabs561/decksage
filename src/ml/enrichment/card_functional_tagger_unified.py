#!/usr/bin/env python3 """ Unified Functional Tagging Interface Provides a single interface to access functional tags across all supported games. """ import json from pathlib import Path from typing import Dict, Optional from dataclasses import asdict from .card_functional_tagger_pokemon import ( PokemonFunctionalTagger, PokemonFunctionalTags, ) from .card_functional_tagger_yugioh import ( YugiohFunctionalTagger, YugiohFunctionalTags, ) class UnifiedFunctionalTagger: """Unified interface for multi-game functional tagging""" def __init__(self, base_path: Path = None): """Initialize taggers for all games""" if base_path is None: base_path = Path(__file__).parent.parent.parent self.pokemon_tagger = PokemonFunctionalTagger(base_path) self.yugioh_tagger = YugiohFunctionalTagger(base_path) # Load cached tags if available self.pokemon_cache = self._load_tag_cache("pokemon_functional_tags.json") self.yugioh_cache = self._load_tag_cache("yugioh_functional_tags.json") print(f"Loaded {len(self.pokemon_cache)} Pokemon tags from cache") print(f"Loaded {len(self.yugioh_cache)} Yu-Gi-Oh! tags from cache") def _load_tag_cache(self, filename: str) -> Dict[str, Dict]: """Load pre-computed tags from cache""" cache_path = Path(__file__).parent / filename if not cache_path.exists(): return {} try: with open(cache_path) as f: tag_list = json.load(f) return {item["card_name"]: item for item in tag_list} except Exception as e: print(f"Warning: Could not load tag cache {filename}: {e}") return {} def get_tags(self, card_name: str, game: str) -> Optional[Dict]: """Get functional tags for a card in any game""" game = game.lower() if game == "magic" or game == "mtg": # MTG tags would come from the original tagger # For now, return None to indicate we'd need to implement this return None elif game == "pokemon": # Try cache first if card_name in self.pokemon_cache: return self.pokemon_cache[card_name] # Fall back to live tagging tags = self.pokemon_tagger.tag_card(card_name) return asdict(tags) elif game == "yugioh" or game == "ygo": # Try cache first if card_name in self.yugioh_cache: return self.yugioh_cache[card_name] # Fall back to live tagging tags = self.yugioh_tagger.tag_card(card_name) return asdict(tags) else: raise ValueError(f"Unsupported game: {game}") def get_deck_tags(self, deck_cards: list[str], game: str) -> Dict[str, Dict]: """Get tags for all cards in a deck""" return {card: self.get_tags(card, game) for card in deck_cards} def filter_by_role(self, card_names: list[str], game: str, role: str) -> list[str]: """Filter cards by a specific functional role""" result = [] for card in card_names: tags = self.get_tags(card, game) if tags and tags.get(role, False): result.append(card) return result def get_role_distribution(self, deck_cards: list[str], game: str) -> Dict[str, int]: """Get the distribution of roles in a deck""" role_counts = {} for card in deck_cards: tags = self.get_tags(card, game) if not tags: continue for role, value in tags.items(): if role != "card_name" and value: role_counts[role] = role_counts.get(role, 0) + 1 return role_counts if __name__ == "__main__": # Example usage tagger = UnifiedFunctionalTagger() # Test Pokemon print("\nüîç Testing Pokemon Tags:") poke_tags = tagger.get_tags("Pikachu", "pokemon") if poke_tags: print(f"Pikachu roles: {[k for k, v in poke_tags.items() if v and k != 'card_name']}") # Test Yu-Gi-Oh print("\nüîç Testing Yu-Gi-Oh! Tags:") ygo_tags = tagger.get_tags("Dark Magician", "yugioh") if ygo_tags: print(f"Dark Magician roles: {[k for k, v in ygo_tags.items() if v and k != 'card_name']}") print("\n Unified tagger operational")
