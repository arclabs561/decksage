#!/usr/bin/env python3 """ Pokemon TCG Functional Tagging System Assigns functional roles to Pokemon cards based on attacks, abilities, and types. """ import json import subprocess import tempfile from dataclasses import dataclass, asdict from pathlib import Path from typing import Dict, List @dataclass class PokemonFunctionalTags: """Functional classification for Pokemon cards""" card_name: str # Pokemon roles attacker: bool = False # High damage output tank: bool = False # High HP energy_acceleration: bool = False # Accelerates energy attachment draw_support: bool = False # Draws cards search_support: bool = False # Searches deck # Attack types spread_damage: bool = False # Damages multiple targets snipe: bool = False # Damages bench mill: bool = False # Discards opponent's deck hand_disruption: bool = False # Disrupts opponent's hand # Abilities & effects ability_lock: bool = False # Shuts down abilities item_lock: bool = False # Prevents item usage switch_effect: bool = False # Free retreat or switching healing: bool = False # Heals damage energy_disruption: bool = False # Removes opponent's energy # Setup & utility evolution_support: bool = False # Helps evolve Pokemon tool_support: bool = False # Related to Pokemon Tools stadium_control: bool = False # Stadium manipulation # Win conditions ohko_potential: bool = False # One-hit KO capability (200+ damage) stall_win_con: bool = False # Wins by stalling/mill class PokemonFunctionalTagger: """Tags Pokemon cards with functional roles""" def __init__(self, card_data_path: Path = None): """Initialize with card data from pokemontcg-data source""" self.card_db = {} if card_data_path: self.card_db = self._load_card_database(card_data_path) def _load_card_database(self, base_path: Path) -> Dict[str, Dict]: """Load Pokemon cards from integration_test_tmp (with zstd decompression)""" cards = {} # Path to our extracted cards (note: double games/ nesting from blob storage) cards_dir = base_path / "integration_test_tmp" / "games" / "games" / "pokemon" / "pokemontcg-data" / "cards" if not cards_dir.exists(): print(f"Warning: Cards directory not found at {cards_dir}") return cards for card_file in cards_dir.glob("*.json.zst"): try: # Use zstd command-line tool for decompression (more reliable) result = subprocess.run( ["zstd", "-d", "-c", str(card_file)], capture_output=True, check=True ) card_data = json.loads(result.stdout) cards[card_data["name"]] = card_data except Exception as e: # Skip files that can't be decompressed continue print(f"Loaded {len(cards)} Pokemon cards") return cards def tag_card(self, card_name: str, card_data: Dict = None) -> PokemonFunctionalTags: """Tag a Pokemon card with functional roles""" tags = PokemonFunctionalTags(card_name=card_name) if card_data is None: card_data = self.card_db.get(card_name, {}) if not card_data: return tags # Extract card properties hp = card_data.get("hp", "") attacks = card_data.get("attacks", []) or [] abilities = card_data.get("abilities", []) or [] supertype = card_data.get("supertype", "").lower() subtypes = [st.lower() for st in (card_data.get("subtypes") or [])] # Skip non-Pokemon cards if supertype != "pokémon": return tags # Analyze HP for tank role try: hp_val = int(hp) if hp else 0 tags.tank = hp_val >= 200 except: pass # Analyze attacks max_damage = 0 for attack in attacks: attack_text = (attack.get("text", "") + " " + attack.get("name", "")).lower() damage_str = attack.get("damage", "") # Parse damage try: if damage_str and damage_str != "": # Handle formats like "120", "120+", "120×" damage = int(''.join(filter(str.isdigit, damage_str))) max_damage = max(max_damage, damage) except: pass # Attack type classification if "each of your opponent" in attack_text or "to each" in attack_text: tags.spread_damage = True if "bench" in attack_text and "damage" in attack_text: tags.snipe = True if "discard" in attack_text and ("deck" in attack_text or "top" in attack_text): tags.mill = True if "switch" in attack_text or "retreat" in attack_text: tags.switch_effect = True if "heal" in attack_text or "remove" in attack_text and "damage" in attack_text: tags.healing = True if "discard" in attack_text and "energy" in attack_text and ("opponent" in attack_text or "defending" in attack_text): tags.energy_disruption = True if "hand" in attack_text and ("discard" in attack_text or "shuffle" in attack_text): tags.hand_disruption = True # Attacker role tags.attacker = max_damage >= 120 tags.ohko_potential = max_damage >= 200 # Analyze abilities for ability in abilities: ability_text = (ability.get("text", "") + " " + ability.get("name", "")).lower() if "draw" in ability_text and "card" in ability_text: tags.draw_support = True if "search" in ability_text and "deck" in ability_text: tags.search_support = True if "attach" in ability_text and "energy" in ability_text: tags.energy_acceleration = True if "evolve" in ability_text or "evolution" in ability_text: tags.evolution_support = True if "abilities" in ability_text and ("can't" in ability_text or "cannot" in ability_text): tags.ability_lock = True if "item" in ability_text and ("can't" in ability_text or "cannot" in ability_text): tags.item_lock = True if "stadium" in ability_text: tags.stadium_control = True if "tool" in ability_text or "pokemon tool" in ability_text: tags.tool_support = True if "retreat" in ability_text and "free" in ability_text or "retreat cost" in ability_text: tags.switch_effect = True # Stall/mill win condition heuristics if tags.mill or (tags.healing and tags.tank): tags.stall_win_con = True return tags def tag_deck_cards(self, deck_cards: List[str]) -> Dict[str, PokemonFunctionalTags]: """Tag all cards in a deck""" result = {} for card_name in deck_cards: result[card_name] = self.tag_card(card_name) return result def export_tags(self, output_path: Path): """Export all tags for cards in database""" print(f"Tagging {len(self.card_db)} Pokemon cards...") results = [] for card_name in self.card_db: tags = self.tag_card(card_name) results.append(asdict(tags)) with open(output_path, "w") as f: json.dump(results, f, indent=2) print(f" Exported {len(results)} Pokemon card tags to {output_path}") return results if __name__ == "__main__": # Use relative path from src/ml to project root base_path = Path(__file__).parent.parent.parent tagger = PokemonFunctionalTagger(base_path) # Export all tags output = Path("pokemon_functional_tags.json") results = tagger.export_tags(output) # Show statistics if results: print("\n Pokemon Tag Distribution:") total = len(results) tag_counts = {} for item in results: for key, value in item.items(): if key != "card_name" and value: tag_counts[key] = tag_counts.get(key, 0) + 1 for tag, count in sorted(tag_counts.items(), key=lambda x: -x[1]): pct = 100 * count / total print(f"{tag:30s}: {count:5d} ({pct:.1f}%)")
