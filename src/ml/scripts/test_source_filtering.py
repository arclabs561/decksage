#!/usr/bin/env python3 """ Test source filtering functionality. Validates that: 1. Decks can be loaded and filtered by source 2. Tournament metadata is accessible 3. Statistics functions work correctly """ from pathlib import Path from utils.data_loading import deck_stats, group_by_source, load_decks_jsonl, load_tournament_decks def test_basic_loading(): """Test basic deck loading from JSONL.""" project_root = Path(__file__).resolve().parents[1] default = project_root / "../backend/decks_hetero.jsonl" fixture = Path(__file__).resolve().parent / "tests" / "fixtures" / "decks_export_hetero_small.jsonl" jsonl_path = default if default.exists() else fixture if not jsonl_path.exists(): print("Warning: No decks_hetero.jsonl found - need to export first") print( " Run: cd ../backend && go run ./cmd/export-hetero data-full/games/magic decks_hetero.jsonl" ) return False # Load all decks all_decks = load_decks_jsonl(jsonl_path) print(f" Loaded {len(all_decks)} total decks") # Check first deck structure if all_decks: first = all_decks[0] print("\nüìã Sample deck fields:") print(f" deck_id: {first.get('deck_id', 'N/A')}") print(f" format: {first.get('format', 'N/A')}") print(f" archetype: {first.get('archetype', 'N/A')}") print(f" source: {first.get('source', 'N/A')}") print(f" player: {first.get('player', 'N/A')}") print(f" event: {first.get('event', 'N/A')}") print(f" placement: {first.get('placement', 'N/A')}") return True def test_source_filtering(): """Test filtering by source.""" project_root = Path(__file__).resolve().parents[1] default = project_root / "../backend/decks_hetero.jsonl" fixture = Path(__file__).resolve().parent / "tests" / "fixtures" / "decks_export_hetero_small.jsonl" jsonl_path = default if default.exists() else fixture if not jsonl_path.exists(): return False # Filter tournament decks only tournament_decks = load_tournament_decks(jsonl_path) print(f"\n Filtered to {len(tournament_decks)} tournament decks (mtgtop8 + goldfish)") # Group by source by_source = group_by_source(tournament_decks) print("\nüìç Decks by source:") for source, decks in sorted(by_source.items()): print(f" {source}: {len(decks)} decks") return True def test_tournament_metadata(): """Test accessing tournament metadata.""" project_root = Path(__file__).resolve().parents[1] default = project_root / "../backend/decks_hetero.jsonl" fixture = Path(__file__).resolve().parent / "tests" / "fixtures" / "decks_export_hetero_small.jsonl" jsonl_path = default if default.exists() else fixture if not jsonl_path.exists(): return False # Load tournament decks decks = load_tournament_decks(jsonl_path) # Find decks with placement data with_placement = [d for d in decks if d.get("placement", 0) > 0] print(f"\nüèÜ {len(with_placement)} decks have placement data") if with_placement: # Show top finishes winners = [d for d in with_placement if d["placement"] == 1] top8 = [d for d in with_placement if d["placement"] <= 8] print(f" 1st place finishes: {len(winners)}") print(f" Top 8 finishes: {len(top8)}") # Sample winner if winners: winner = winners[0] print("\n Sample winner:") print(f" - Player: {winner.get('player', 'N/A')}") print(f" - Event: {winner.get('event', 'N/A')}") print(f" - Archetype: {winner.get('archetype', 'N/A')}") print(f" - Format: {winner.get('format', 'N/A')}") return True def test_stats(): """Test statistics functions.""" project_root = Path(__file__).resolve().parents[1] default = project_root / "../backend/decks_hetero.jsonl" fixture = Path(__file__).resolve().parent / "tests" / "fixtures" / "decks_export_hetero_small.jsonl" jsonl_path = default if default.exists() else fixture if not jsonl_path.exists(): return False decks = load_tournament_decks(jsonl_path) stats = deck_stats(decks) print("\n Deck Statistics:") print(f" Total decks: {stats['total']}") print(f" Sources: {len(stats['by_source'])}") print(f" Formats: {len(stats['by_format'])}") print(f" Archetypes: {len(stats['by_archetype'])}") if stats["total"] > 0: print( f" Has player: {stats['has_player']} ({100.0 * stats['has_player'] / stats['total']:.1f}%)" ) print( f" Has event: {stats['has_event']} ({100.0 * stats['has_event'] / stats['total']:.1f}%)" ) print( f" Has placement: {stats['has_placement']} ({100.0 * stats['has_placement'] / stats['total']:.1f}%)" ) return True def test_format_filtering(): """Test filtering by format.""" project_root = Path(__file__).resolve().parents[1] default = project_root / "../backend/decks_hetero.jsonl" fixture = Path(__file__).resolve().parent / "tests" / "fixtures" / "decks_export_hetero_small.jsonl" jsonl_path = default if default.exists() else fixture if not jsonl_path.exists(): return False # Load Modern decks only modern_decks = load_decks_jsonl(jsonl_path, formats=["Modern"]) print(f"\n Filtered to {len(modern_decks)} Modern decks") # Load Top 8 finishes only top8_decks = load_decks_jsonl(jsonl_path, max_placement=8) print(f" Filtered to {len(top8_decks)} Top 8 finishes") # Combine filters: Modern Top 8 from mtgtop8 modern_top8 = load_decks_jsonl( jsonl_path, sources=["mtgtop8"], formats=["Modern"], max_placement=8 ) print(f" Filtered to {len(modern_top8)} Modern Top 8 decks from mtgtop8") return True if __name__ == "__main__": print("=" * 80) print("SOURCE FILTERING TEST SUITE") print("=" * 80) tests = [ ("Basic Loading", test_basic_loading), ("Source Filtering", test_source_filtering), ("Tournament Metadata", test_tournament_metadata), ("Statistics", test_stats), ("Format Filtering", test_format_filtering), ] results = [] for name, test_fn in tests: print(f"\n{'=' * 80}") print(f"TEST: {name}") print(f"{'=' * 80}") try: success = test_fn() results.append((name, success)) except Exception as e: print(f"Error: Test failed with error: {e}") results.append((name, False)) # Summary print(f"\n{'=' * 80}") print("TEST SUMMARY") print(f"{'=' * 80}\n") for name, success in results: status = " PASS" if success else "Error: FAIL" print(f"{status}: {name}") passed = sum(1 for _, s in results if s) print(f"\nPassed: {passed}/{len(results)}")