#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # /// """ Verify that repaired test sets are clean. Checks for: 1. No cross-game contamination 2. No duplicate cards 3. No contradictions 4. Explicit game metadata """ import argparse import json import logging from pathlib import Path from typing import Any from ml.utils.logging_config import setup_script_logging logger = setup_script_logging() # Import validation import sys from pathlib import Path as P script_dir = P(__file__).parent src_dir = script_dir.parent.parent if str(src_dir) not in sys.path: sys.path.insert(0, str(src_dir)) try: from ml.scripts.validate_labels import validate_labels HAS_VALIDATION = True except ImportError: HAS_VALIDATION = False logger.warning("Validation script not available") def verify_test_set(test_set_path: Path, game: str | None = None) -> dict[str, Any]: """Verify a test set is clean.""" logger.info(f"Verifying: {test_set_path}") with open(test_set_path) as f: data = json.load(f) # Check game metadata has_game_metadata = "game" in data and data["game"] in ["magic", "pokemon", "yugioh"] detected_game = data.get("game") or game if not detected_game: logger.warning("No game metadata found") return {"valid": False, "reason": "No game metadata"} # Use validation script if available if HAS_VALIDATION: issues = validate_labels(test_set_path, None, detected_game) is_valid = ( issues["queries_with_issues"] == 0 and len(issues["cross_game_contamination"]) == 0 and len(issues["duplicate_cards"]) == 0 and len(issues["contradictions"]) == 0 ) return { "valid": is_valid, "has_game_metadata": has_game_metadata, "game": detected_game, "issues": issues, } else: # Basic check queries = data.get("queries", data) if isinstance(data, dict) else data has_issues = False for query_name, query_data in queries.items(): if not isinstance(query_data, dict): continue # Check for duplicates all_cards = [] for level in ["highly_relevant", "relevant", "somewhat_relevant", "marginally_relevant", "irrelevant"]: all_cards.extend(query_data.get(level, [])) if len(all_cards) != len(set(all_cards)): has_issues = True break return { "valid": not has_issues, "has_game_metadata": has_game_metadata, "game": detected_game, } def main() -> int: """Verify repaired test sets.""" parser = argparse.ArgumentParser(description="Verify repaired test sets") parser.add_argument("--input", type=str, required=True, help="Test set JSON to verify") parser.add_argument("--game", type=str, choices=["magic", "pokemon", "yugioh"], help="Game name (auto-detected if not provided)") args = parser.parse_args() result = verify_test_set(Path(args.input), args.game) if result["valid"]: print(" Test set is clean!") print(f" Game: {result['game']}") print(f" Has game metadata: {result['has_game_metadata']}") if "issues" in result: print(f" Total queries: {result['issues']['total_queries']}") print(f" Queries with issues: {result['issues']['queries_with_issues']}") return 0 else: print("Error: Test set has issues") if "issues" in result: print(f" Cross-game contamination: {len(result['issues']['cross_game_contamination'])} queries") print(f" Duplicate cards: {len(result['issues']['duplicate_cards'])} queries") print(f" Contradictions: {len(result['issues']['contradictions'])} queries") return 1 if __name__ == "__main__": import sys sys.exit(main())
