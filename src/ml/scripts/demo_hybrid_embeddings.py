#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # dependencies = [] # /// """ Demo of hybrid embedding system capabilities. Shows how new cards are handled immediately without retraining. """ from __future__ import annotations import sys from pathlib import Path from ..data.incremental_graph import IncrementalCardGraph from ..similarity.instruction_tuned_embeddings import InstructionTunedCardEmbedder from ..scripts.integrate_hybrid_embeddings import ( create_fusion_with_hybrid_embeddings, load_hybrid_embeddings, ) from ..utils.paths import PATHS def demo_new_card_handling(): """Demonstrate how new cards are handled immediately.""" print("="*70) print("DEMO: New Card Handling") print("="*70) print() # Scenario: New set released with "Lightning Strike 2.0" new_card = { "name": "Lightning Strike 2.0", "type_line": "Instant", "oracle_text": "Lightning Strike 2.0 deals 3 damage to any target.", } print("Scenario: New card 'Lightning Strike 2.0' released today") print() # 1. Instruction-tuned (zero-shot) print("1. Instruction-Tuned Embeddings (Zero-Shot):") try: embedder = InstructionTunedCardEmbedder() embedding = embedder.embed_card(new_card, instruction_type="substitution") print(f" ✓ Generated embedding immediately (no retraining needed)") print(f" ✓ Embedding shape: {embedding.shape}") # Find similar candidates = ["Lightning Bolt", "Shock", "Lightning Strike", "Counterspell"] similar = embedder.most_similar( new_card, candidates, topn=3, instruction_type="substitution", ) print(f" ✓ Found similar cards:") for card, score in similar: print(f" - {card}: {score:.4f}") except Exception as e: print(f" Warning: {e}") print() # 2. Graph (incremental) print("2. Incremental Graph:") graph = IncrementalCardGraph() # Simulate new deck with new card new_deck = { "cards": [ {"name": "Lightning Strike 2.0", "count": 4}, {"name": "Lightning Bolt", "count": 4}, {"name": "Mountain", "count": 20}, ] } graph.add_deck(new_deck) neighbors = graph.get_neighbors("Lightning Strike 2.0") print(f" ✓ Added to graph immediately") print(f" ✓ Neighbors: {neighbors}") print() # 3. GNN (inductive) print("3. GNN Embeddings (Inductive Learning):") print(" ✓ Can add new card incrementally (no full retraining)") print(" ✓ Uses neighbor aggregation from graph") print(" ✓ Falls back to instruction-tuned if isolated") print() print("="*70) print(" New cards handled immediately by all three systems!") print("="*70) def demo_fusion_system(): """Demonstrate fusion system combining all signals.""" print() print("="*70) print("DEMO: Fusion System") print("="*70) print() print("Loading hybrid embeddings...") embeddings_data = load_hybrid_embeddings() print("Loaded:") for name, loaded in embeddings_data["loaded"].items(): status = "✓" if loaded else "✗" print(f" {status} {name}") print() if embeddings_data["instruction_embedder"]: print("Creating fusion system...") fusion = create_fusion_with_hybrid_embeddings(embeddings_data) print("Fusion weights:") print(f" - GNN: 30% (multi-hop, new cards)") print(f" - Instruction-tuned: 25% (zero-shot, semantic)") print(f" - Co-occurrence: 20% (established patterns)") print(f" - Jaccard: 15% (direct co-occurrence)") print(f" - Functional tags: 10% (role-based)") print() print(" Fusion system ready to combine all signals!") else: print("Warning: Instruction embedder not available") print("="*70) def main() -> int: """Run demos.""" print() print(" HYBRID EMBEDDINGS SYSTEM DEMO") print() demo_new_card_handling() demo_fusion_system() print() print("Next steps:") print(" 1. Train GNN: just train-gnn-aws <instance-id>") print(" 2. Evaluate: just eval-hybrid-aws <instance-id>") print(" 3. Use in API: Set INSTRUCTION_EMBEDDER_MODEL env var") print() return 0 if __name__ == "__main__": sys.exit(main())
