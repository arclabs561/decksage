#!/usr/bin/env python3 """ Expand Pokemon Test Set Expands Pokemon test set from 58 queries to 100+ queries. Uses graph-based candidate selection and LLM labeling. """ from __future__ import annotations import json import logging from pathlib import Path from typing import Any from ..data.card_database import get_card_database from ..utils.data_loading import load_pairs, load_test_set from ..utils.paths import PATHS logger = logging.getLogger(__name__) def get_pokemon_cards_from_database(limit: int = 200) -> list[str]: """ Get Pokemon cards directly from card database. Returns list of Pokemon card names. """ card_db = get_card_database() card_db.load() # Get all Pokemon cards from database pokemon_cards = list(card_db._pokemon_cards) logger.info(f"Found {len(pokemon_cards)} Pokemon cards in database") # If we have pairs data, prioritize by frequency try: pairs_df = load_pairs(dataset="large", game="pokemon") from collections import Counter card_counts = Counter() for _, row in pairs_df.iterrows(): c1, c2 = row["NAME_1"], row["NAME_2"] count = int(row.get("COUNT_MULTISET", 1)) if c1 in pokemon_cards: card_counts[c1] += count if c2 in pokemon_cards: card_counts[c2] += count # Sort by frequency if card_counts: sorted_cards = [card for card, _ in card_counts.most_common(limit)] # Add any missing cards for card in pokemon_cards: if card not in sorted_cards: sorted_cards.append(card) return sorted_cards[:limit] except Exception as e: logger.warning(f"Could not load pairs for frequency sorting: {e}") # Fallback: return all Pokemon cards return pokemon_cards[:limit] def select_diverse_queries( existing_queries: set[str], candidate_cards: list[str], num_needed: int, ) -> list[str]: """ Select diverse query candidates from available cards. Avoids duplicates and prioritizes cards with high graph connectivity. """ selected = [] for card in candidate_cards: if card not in existing_queries and card not in selected: selected.append(card) if len(selected) >= num_needed: break return selected def expand_pokemon_test_set( existing_test_set_path: Path, output_path: Path, target_size: int = 100, ) -> dict[str, Any]: """ Expand Pokemon test set to target size. Strategy: 1. Load existing test set 2. Get Pokemon cards from graph 3. Select diverse candidates 4. Create placeholder entries (labels can be added later) """ # Load existing test set existing_data = {} existing_queries = set() if existing_test_set_path.exists(): with open(existing_test_set_path) as f: data = json.load(f) queries = data.get("queries", data) if isinstance(data, dict) else data existing_data = queries if isinstance(queries, dict) else {} existing_queries = set(existing_data.keys()) current_size = len(existing_queries) num_needed = max(0, target_size - current_size) if num_needed <= 0: logger.info(f"Pokemon test set already at target size: {current_size}") return {"expanded": False, "current_size": current_size} logger.info(f"Expanding Pokemon test set: {current_size} → {target_size} (+{num_needed})") # Get Pokemon cards from database logger.info("Loading Pokemon cards from database...") candidate_cards = get_pokemon_cards_from_database(limit=num_needed * 3) logger.info(f"Found {len(candidate_cards)} Pokemon card candidates") # Select diverse queries new_queries = select_diverse_queries( existing_queries=existing_queries, candidate_cards=candidate_cards, num_needed=num_needed, ) logger.info(f"Selected {len(new_queries)} new queries") # Create placeholder entries for query in new_queries: existing_data[query] = { "type": "unknown", "sources": ["graph_based_expansion"], "highly_relevant": [], "relevant": [], "somewhat_relevant": [], "marginally_relevant": [], "irrelevant": [], } # Save expanded test set output_data = { "version": "expanded_v1", "game": "pokemon", "description": f"Expanded from {current_size} to {len(existing_data)} queries", "queries": existing_data, } output_path.parent.mkdir(parents=True, exist_ok=True) with open(output_path, "w") as f: json.dump(output_data, f, indent=2) logger.info(f" Expanded Pokemon test set: {current_size} → {len(existing_data)} queries") logger.info(f" Saved to: {output_path}") return { "expanded": True, "current_size": current_size, "new_size": len(existing_data), "added": len(new_queries), } def main() -> int: """CLI for expanding Pokemon test set.""" import argparse parser = argparse.ArgumentParser(description="Expand Pokemon test set") parser.add_argument( "--test-set", type=Path, default=PATHS.test_pokemon, help="Path to existing Pokemon test set", ) parser.add_argument( "--output", type=Path, help="Output path (default: overwrite input)", ) parser.add_argument( "--target-size", type=int, default=100, help="Target number of queries", ) args = parser.parse_args() logging.basicConfig(level=logging.INFO) output_path = args.output or args.test_set results = expand_pokemon_test_set( existing_test_set_path=args.test_set, output_path=output_path, target_size=args.target_size, ) if results.get("expanded"): print(f"\n Expanded: {results['current_size']} → {results['new_size']} queries") print(f" Added: {results['added']} new queries") print(f"\nNote: New queries have placeholder labels. Add labels using:") print(f" just annotate-llm 50 diverse # Generate LLM labels") else: print(f"\n Already at target size: {results['current_size']} queries") return 0 if __name__ == "__main__": import sys sys.exit(main())
