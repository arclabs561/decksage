#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # dependencies = [ # "pandas>=2.0.0", # ] # /// """ Generate test data for downstream task evaluation. Creates: 1. Test decks (partial decks for completion, full decks for refinement) 2. Test substitution pairs (from canonical test sets) 3. Test contextual queries (from canonical test sets) """ from __future__ import annotations import argparse import json import random from pathlib import Path from typing import Any from ml.utils.logging_config import setup_script_logging try: import pandas as pd HAS_DEPS = True except ImportError: HAS_DEPS = False import sys script_dir = Path(__file__).parent src_dir = script_dir.parent.parent if str(src_dir) not in sys.path: sys.path.insert(0, str(src_dir)) from ml.utils.paths import PATHS def generate_completion_test_decks( decks_path: Path, output_path: Path, game: str = "magic", num_decks: int = 20, min_cards_to_remove: int = 10, max_cards_to_remove: int = 20, logger=None, ) -> None: """Generate partial decks for completion testing.""" if logger is None: import logging logger = setup_script_logging() logger.info(f"Generating {num_decks} completion test decks from {decks_path}...") decks: list[dict] = [] with open(decks_path) as f: for line in f: if line.strip(): deck = json.loads(line) # Filter by game if deck.get("game") == game or (game == "magic" and "game" not in deck): decks.append(deck) if len(decks) < num_decks: logger.warning(f"Only {len(decks)} decks available, generating {len(decks)} test decks") num_decks = len(decks) # Sample decks sampled = random.sample(decks, min(num_decks, len(decks))) main_partition = "Main" if game == "magic" else "Main Deck" test_decks: list[dict] = [] for deck in sampled: # Create partial deck partial_deck = json.loads(json.dumps(deck)) # Deep copy for p in partial_deck.get("partitions", []) or []: if p.get("name") == main_partition: cards = p.get("cards", []) or [] if len(cards) > min_cards_to_remove: # Remove random cards num_to_remove = random.randint(min_cards_to_remove, min(max_cards_to_remove, len(cards) - 5)) p["cards"] = cards[:-num_to_remove] break test_decks.append(partial_deck) # Save output_path.parent.mkdir(parents=True, exist_ok=True) with open(output_path, "w") as f: for deck in test_decks: f.write(json.dumps(deck) + "\n") logger.info(f" Generated {len(test_decks)} completion test decks -> {output_path}") def generate_refinement_test_decks( decks_path: Path, output_path: Path, game: str = "magic", num_decks: int = 20, logger=None, ) -> None: """Generate full decks for refinement testing.""" if logger is None: import logging logger = setup_script_logging() logger.info(f"Generating {num_decks} refinement test decks from {decks_path}...") decks: list[dict] = [] with open(decks_path) as f: for line in f: if line.strip(): deck = json.loads(line) # Filter by game if deck.get("game") == game or (game == "magic" and "game" not in deck): decks.append(deck) if len(decks) < num_decks: logger.warning(f"Only {len(decks)} decks available, generating {len(decks)} test decks") num_decks = len(decks) # Sample decks sampled = random.sample(decks, min(num_decks, len(decks))) # Save output_path.parent.mkdir(parents=True, exist_ok=True) with open(output_path, "w") as f: for deck in sampled: f.write(json.dumps(deck) + "\n") logger.info(f" Generated {len(sampled)} refinement test decks -> {output_path}") def generate_substitution_test_pairs( test_set_path: Path, output_path: Path, game: str = "magic", logger=None, ) -> None: """Generate substitution pairs from canonical test set.""" if logger is None: import logging logger = setup_script_logging() logger.info(f"Generating substitution pairs from {test_set_path}...") if not test_set_path.exists(): logger.warning(f"Test set not found: {test_set_path}") return with open(test_set_path) as f: test_set = json.load(f) pairs: list[tuple[str, str]] = [] # Handle different test set formats if isinstance(test_set, dict): # Check if it has a "queries" key (nested format) if "queries" in test_set: queries = test_set["queries"] else: queries = test_set # Extract pairs from test set (query -> highly_relevant/relevant cards) for query, labels in queries.items(): # Handle both dict and string labels if isinstance(labels, str): continue # Skip string labels # Get highly relevant and relevant cards highly_relevant = labels.get("highly_relevant", []) if isinstance(labels, dict) else [] relevant = labels.get("relevant", []) if isinstance(labels, dict) else [] # Create pairs: (query, target) for target in highly_relevant + relevant: pairs.append((query, target)) # Save output_path.parent.mkdir(parents=True, exist_ok=True) with open(output_path, "w") as f: json.dump(pairs, f, indent=2) logger.info(f" Generated {len(pairs)} substitution pairs -> {output_path}") def generate_contextual_test_queries( test_set_path: Path, output_path: Path, game: str = "magic", logger=None, ) -> None: """Generate contextual queries from canonical test set.""" if logger is None: import logging logger = setup_script_logging() logger.info(f"Generating contextual queries from {test_set_path}...") if not test_set_path.exists(): logger.warning(f"Test set not found: {test_set_path}") return with open(test_set_path) as f: test_set = json.load(f) queries: list[dict] = [] # Handle different test set formats if isinstance(test_set, dict): # Check if it has a "queries" key (nested format) if "queries" in test_set: queries_dict = test_set["queries"] else: queries_dict = test_set # Create queries from test set for query, labels in queries_dict.items(): # Handle both dict and string labels if isinstance(labels, str): continue # Skip string labels query_obj = { "card": query, "expected_synergies": labels.get("somewhat_relevant", [])[:5] if isinstance(labels, dict) else [], # Synergies are somewhat_relevant "expected_alternatives": labels.get("highly_relevant", [])[:5] if isinstance(labels, dict) else [], # Alternatives are highly_relevant } queries.append(query_obj) # Save output_path.parent.mkdir(parents=True, exist_ok=True) with open(output_path, "w") as f: json.dump(queries, f, indent=2) logger.info(f" Generated {len(queries)} contextual queries -> {output_path}") def main() -> int: """Generate test data for downstream tasks.""" import logging global logger logger = setup_script_logging() parser = argparse.ArgumentParser(description="Generate test data for downstream tasks") parser.add_argument("--game", type=str, default="magic", choices=["magic", "pokemon", "yugioh"], help="Game to generate test data for") parser.add_argument("--decks", type=str, help="Input decks JSONL (default: decks_all_final.jsonl)") parser.add_argument("--test-set", type=str, help="Canonical test set JSON") parser.add_argument("--output-dir", type=str, default="experiments/downstream_test_data", help="Output directory") parser.add_argument("--num-decks", type=int, default=20, help="Number of test decks to generate") args = parser.parse_args() if not HAS_DEPS: logger.error("Missing dependencies") return 1 output_dir = Path(args.output_dir) output_dir.mkdir(parents=True, exist_ok=True) # Determine input paths if args.decks: decks_path = Path(args.decks) else: decks_path = PATHS.decks_all_final if args.test_set: test_set_path = Path(args.test_set) else: # Use canonical test set for game if args.game == "magic": test_set_path = PATHS.test_magic elif args.game == "pokemon": test_set_path = PATHS.test_pokemon elif args.game == "yugioh": test_set_path = PATHS.test_yugioh else: test_set_path = PATHS.test_magic # Generate test data logger.info(f"Generating test data for {args.game}...") # Completion test decks completion_path = output_dir / f"{args.game}_completion_test_decks.jsonl" if decks_path.exists(): generate_completion_test_decks( decks_path=decks_path, output_path=completion_path, game=args.game, num_decks=args.num_decks, logger=logger, ) else: logger.warning(f"Decks file not found: {decks_path}") # Refinement test decks refinement_path = output_dir / f"{args.game}_refinement_test_decks.jsonl" if decks_path.exists(): generate_refinement_test_decks( decks_path=decks_path, output_path=refinement_path, game=args.game, num_decks=args.num_decks, logger=logger, ) else: logger.warning(f"Decks file not found: {decks_path}") # Substitution pairs substitution_path = output_dir / f"{args.game}_substitution_test_pairs.json" if test_set_path.exists(): generate_substitution_test_pairs( test_set_path=test_set_path, output_path=substitution_path, game=args.game, logger=logger, ) else: logger.warning(f"Test set not found: {test_set_path}") # Contextual queries contextual_path = output_dir / f"{args.game}_contextual_test_queries.json" if test_set_path.exists(): generate_contextual_test_queries( test_set_path=test_set_path, output_path=contextual_path, game=args.game, logger=logger, ) else: logger.warning(f"Test set not found: {test_set_path}") logger.info(f"\n Test data generation complete!") logger.info(f" Output directory: {output_dir}") return 0 if __name__ == "__main__": import sys import logging sys.exit(main())
