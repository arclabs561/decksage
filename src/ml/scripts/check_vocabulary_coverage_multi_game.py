#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # dependencies = [ # "pandas>=2.0.0", # "numpy<2.0.0", # "gensim>=4.3.0", # ] # /// """Check vocabulary coverage for multi-game evaluation.""" import json import sys from pathlib import Path sys.path.insert(0, str(Path(__file__).parent.parent.parent)) from gensim.models import KeyedVectors from ml.utils.name_normalizer import NameMapper from ml.utils.shared_operations import load_embeddings, get_embedding_path from ml.utils.paths import PATHS EMBEDDINGS = { "heterogeneous": str(PATHS.embeddings / "trained_heterogeneous_substitution.wv"), "triplet": str(PATHS.embeddings / "trained_triplet_substitution.wv"), } TEST_SETS = { "magic": str(PATHS.test_magic), "pokemon": str(PATHS.test_pokemon), "yugioh": str(PATHS.test_yugioh), } def check_vocabulary_coverage(): """Check vocabulary coverage for each embedding on each game.""" print("=" * 70) print("VOCABULARY COVERAGE ANALYSIS") print("=" * 70) print() # Load name mapper from ml.utils.paths import PATHS name_mapping_path = PATHS.data / "processed" / "name_mapping.json" name_mapper = None if name_mapping_path.exists(): name_mapper = NameMapper.load_from_file(name_mapping_path) print(" Loaded name mapper") else: print("Warning: No name mapper found") results = {} for emb_name, emb_path in EMBEDDINGS.items(): emb_path_obj = Path(emb_path) if not emb_path_obj.exists(): print(f"⏭️ Skipping {emb_name}: Not found") continue print(f"\n {emb_name}:") wv = KeyedVectors.load(emb_path) vocab = set(wv.key_to_index.keys()) print(f" Vocabulary size: {len(vocab)}") results[emb_name] = {} for game, test_set_path in TEST_SETS.items(): test_set_path_obj = Path(test_set_path) if not test_set_path_obj.exists(): print(f" ⏭️ {game}: Test set not found") continue with open(test_set_path) as f: data = json.load(f) queries = data.get("queries", data) if isinstance(data, dict) else data # Count coverage total_queries = len(queries) if isinstance(queries, dict) else 0 covered = 0 mapped_covered = 0 for query in queries.keys() if isinstance(queries, dict) else []: # Direct match if query in vocab: covered += 1 # Mapped match elif name_mapper: mapped = name_mapper.map_name(query) if mapped in vocab: mapped_covered += 1 total_covered = covered + mapped_covered coverage = total_covered / total_queries * 100 if total_queries > 0 else 0.0 results[emb_name][game] = { "total_queries": total_queries, "direct_covered": covered, "mapped_covered": mapped_covered, "total_covered": total_covered, "coverage_pct": coverage, } print(f" {game:10s}: {total_covered:3d}/{total_queries:3d} ({coverage:.1f}%) - Direct: {covered}, Mapped: {mapped_covered}") # Save results output_path = PATHS.experiments / "vocabulary_coverage.json" with open(output_path, "w") as f: json.dump(results, f, indent=2) print(f"\n Saved to {output_path}") if __name__ == "__main__": check_vocabulary_coverage()
