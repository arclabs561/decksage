#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # dependencies = [ # "pandas>=2.0.0", # "numpy<2.0.0", # "gensim>=4.3.0", # ] # /// """Evaluate all embeddings on all games.""" import json import sys from pathlib import Path sys.path.insert(0, str(Path(__file__).parent.parent.parent)) from gensim.models import KeyedVectors from ml.utils.evaluation import evaluate_with_confidence from ml.utils.name_normalizer import NameMapper from ml.utils.paths import PATHS EMBEDDINGS = { "heterogeneous": str(PATHS.embeddings / "trained_heterogeneous_substitution.wv"), "triplet": str(PATHS.embeddings / "trained_triplet_substitution.wv"), "contrastive": str(PATHS.embeddings / "trained_contrastive_substitution.wv"), "functional_improved": str(PATHS.embeddings / "trained_functional_improved.wv"), } TEST_SETS = { "magic": str(PATHS.test_magic), "pokemon": str(PATHS.test_pokemon), "yugioh": str(PATHS.test_yugioh), } def evaluate_embedding_on_game(embedding_name: str, embedding_path: str, game: str, test_set_path: str): """Evaluate an embedding on a game.""" print(f" Evaluating {embedding_name} on {game}...") # Load embedding try: wv = KeyedVectors.load(embedding_path) except Exception as e: print(f" Error: Failed to load: {e}") return None # Load test set try: with open(test_set_path) as f: data = json.load(f) queries = data.get("queries", data) if isinstance(data, dict) else data except Exception as e: print(f" Error: Failed to load test set: {e}") return None # Load name mapper name_mapping_path = Path("data/processed/name_mapping.json") if name_mapping_path.exists(): name_mapper = NameMapper.load_from_file(name_mapping_path) else: name_mapper = None # Convert test set format test_queries = {} for query, labels in queries.items(): if isinstance(labels, dict): # Convert to flat list relevant = [] for level in ["highly_relevant", "relevant", "somewhat_relevant"]: relevant.extend(labels.get(level, [])) test_queries[query] = relevant # Create similarity function def similarity_func(query: str, k: int): """Similarity function for evaluation.""" # Map query name if mapper available mapped_query = name_mapper.map_name(query) if name_mapper else query if mapped_query not in wv: return [] similar = wv.most_similar(mapped_query, topn=k) return similar # Evaluate try: results = evaluate_with_confidence( test_set=test_queries, similarity_func=similarity_func, top_k=10, n_bootstrap=100, ) # Extract results (handle different return formats) p_at_10 = results.get("p@10", results.get("p_at_10", 0.0)) p_at_10_ci = results.get("p@10_ci", results.get("p_at_10_ci", [0.0, 0.0])) mrr = results.get("mrr", results.get("mrr@10", 0.0)) mrr_ci = results.get("mrr_ci", results.get("mrr@10_ci", [0.0, 0.0])) return { "p@10": p_at_10, "p@10_ci": p_at_10_ci if isinstance(p_at_10_ci, list) else [p_at_10_ci, p_at_10_ci], "mrr": mrr, "mrr_ci": mrr_ci if isinstance(mrr_ci, list) else [mrr_ci, mrr_ci], "n_queries": len(test_queries), } except Exception as e: print(f" Error: Evaluation failed: {e}") return None if __name__ == "__main__": all_results = {} for embedding_name, embedding_path in EMBEDDINGS.items(): embedding_path_obj = Path(embedding_path) if not embedding_path_obj.exists(): print(f"⏭️ Skipping {embedding_name}: Not found") continue all_results[embedding_name] = {} for game, test_set_path in TEST_SETS.items(): test_set_path_obj = Path(test_set_path) if not test_set_path_obj.exists(): print(f"⏭️ Skipping {game}: Test set not found") continue result = evaluate_embedding_on_game(embedding_name, embedding_path, game, test_set_path) if result: all_results[embedding_name][game] = result # Save results output_path = Path("experiments/multi_game_evaluation.json") with open(output_path, "w") as f: json.dump(all_results, f, indent=2) print() print("=" * 70) print("MULTI-GAME EVALUATION RESULTS") print("=" * 70) print() for embedding_name, game_results in all_results.items(): print(f"{embedding_name}:") for game, result in game_results.items(): p_at_10 = result["p@10"] ci = result["p@10_ci"] print(f" {game:10s}: P@10={p_at_10:.3f} [{ci[0]:.3f}, {ci[1]:.3f}]") print() print(f" Saved to {output_path}")
