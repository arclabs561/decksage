#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # dependencies = [ # "pyyaml>=6.0", # ] # /// """ Compute IAA for hand annotations when multiple annotators review the same batch. Compares annotations from different annotators on the same query-candidate pairs. """ from __future__ import annotations import argparse import json from collections import defaultdict from pathlib import Path from typing import Any try: import yaml HAS_YAML = True except ImportError: HAS_YAML = False print("Install pyyaml: pip install pyyaml") import sys script_dir = Path(__file__).parent src_dir = script_dir.parent.parent if str(src_dir) not in sys.path: sys.path.insert(0, str(src_dir)) try: from ml.evaluation.inter_annotator_agreement import InterAnnotatorAgreement HAS_IAA = True except ImportError: HAS_IAA = False print("IAA module not available") def load_annotations_by_annotator(annotation_path: Path) -> dict[str, list[dict[str, Any]]]: """Load annotations grouped by annotator ID.""" if not HAS_YAML: return {} with open(annotation_path) as f: data = yaml.safe_load(f) tasks = data.get("tasks", []) annotations_by_annotator: dict[str, list[dict[str, Any]]] = defaultdict(list) for task in tasks: query = task.get("query") candidates = task.get("candidates", []) for cand in candidates: annotator_id = cand.get("annotator_id") if not annotator_id: # Use default annotator if not specified annotator_id = "default" relevance = cand.get("relevance") if relevance is None: continue annotations_by_annotator[annotator_id].append({ "query": query, "candidate": cand.get("card"), "relevance": int(relevance), "similarity_type": cand.get("similarity_type"), "is_substitute": cand.get("is_substitute"), }) return dict(annotations_by_annotator) def compute_iaa_for_hand_annotations(annotation_path: Path) -> dict[str, Any]: """Compute IAA for hand annotations.""" if not HAS_IAA: return {"error": "IAA module not available"} annotations_by_annotator = load_annotations_by_annotator(annotation_path) if len(annotations_by_annotator) < 2: return { "error": "Need at least 2 annotators for IAA computation", "annotators_found": len(annotations_by_annotator), } # Group by query-candidate pair pair_annotations: dict[tuple[str, str], list[dict[str, Any]]] = defaultdict(list) for annotator_id, annotations in annotations_by_annotator.items(): for ann in annotations: pair = (ann["query"], ann["candidate"]) pair_annotations[pair].append({ "annotator": annotator_id, "relevance": ann["relevance"], }) # Filter to pairs with multiple annotators multi_annotator_pairs = { pair: anns for pair, anns in pair_annotations.items() if len(anns) >= 2 } if not multi_annotator_pairs: return { "error": "No pairs annotated by multiple annotators", "total_pairs": len(pair_annotations), } # Prepare data for IAA computation annotator_ids = list(annotations_by_annotator.keys()) iaa_calculator = InterAnnotatorAgreement() # Compute pairwise IAA for each pair of annotators pairwise_iaa = {} for i, ann1_id in enumerate(annotator_ids): for ann2_id in annotator_ids[i+1:]: # Get common pairs ann1_pairs = { (ann["query"], ann["candidate"]): ann["relevance"] for ann in annotations_by_annotator[ann1_id] } ann2_pairs = { (ann["query"], ann["candidate"]): ann["relevance"] for ann in annotations_by_annotator[ann2_id] } common_pairs = set(ann1_pairs.keys()) & set(ann2_pairs.keys()) if not common_pairs: continue # Extract relevance scores for common pairs scores1 = [ann1_pairs[pair] for pair in sorted(common_pairs)] scores2 = [ann2_pairs[pair] for pair in sorted(common_pairs)] # Compute Cohen's Kappa kappa_result = iaa_calculator.cohens_kappa(scores1, scores2) pairwise_iaa[f"{ann1_id}_vs_{ann2_id}"] = kappa_result # Compute overall Krippendorff's Alpha if possible # (requires all annotators to rate all items) overall_alpha = None if len(multi_annotator_pairs) >= 10: # Need sufficient data try: # Prepare data matrix: annotators x pairs all_pairs = sorted(multi_annotator_pairs.keys()) data_matrix = [] for annotator_id in annotator_ids: row = [] for pair in all_pairs: # Find this annotator's rating for this pair rating = None for ann in multi_annotator_pairs[pair]: if ann["annotator"] == annotator_id: rating = ann["relevance"] break row.append(rating) data_matrix.append(row) # Transpose for Krippendorff's Alpha (items x annotators) if data_matrix: transposed = list(zip(*data_matrix)) alpha = iaa_calculator.krippendorffs_alpha(transposed, metric="ordinal") overall_alpha = alpha except Exception as e: print(f"Warning: Could not compute overall alpha: {e}") return { "total_annotators": len(annotations_by_annotator), "total_pairs": len(pair_annotations), "multi_annotator_pairs": len(multi_annotator_pairs), "pairwise_iaa": pairwise_iaa, "overall_alpha": overall_alpha, "annotator_ids": annotator_ids, } def main() -> int: parser = argparse.ArgumentParser(description="Compute IAA for hand annotations") parser.add_argument("--input", type=str, required=True, help="Hand annotation YAML file") parser.add_argument("--output", type=str, help="Output JSON report") args = parser.parse_args() annotation_path = Path(args.input) if not annotation_path.exists(): print(f"Error: Annotation file not found: {annotation_path}") return 1 print("=" * 70) print("COMPUTING IAA FOR HAND ANNOTATIONS") print("=" * 70) print() results = compute_iaa_for_hand_annotations(annotation_path) if "error" in results: print(f"Error: Error: {results['error']}") if "annotators_found" in results: print(f" Found {results['annotators_found']} annotator(s)") return 1 print(f" Results:") print(f" Annotators: {results['total_annotators']}") print(f" Total pairs: {results['total_pairs']}") print(f" Multi-annotator pairs: {results['multi_annotator_pairs']}") print() if results["pairwise_iaa"]: print(f"ðŸ“ˆ Pairwise IAA (Cohen's Kappa):") for pair, kappa_result in results["pairwise_iaa"].items(): kappa = kappa_result.get("kappa", 0.0) interpretation = kappa_result.get("interpretation", "unknown") print(f" {pair}: Îº={kappa:.3f} ({interpretation})") print() if results["overall_alpha"] is not None: print(f"ðŸ“ˆ Overall IAA (Krippendorff's Alpha):") print(f" Î±={results['overall_alpha']:.3f}") print() # Save report if requested if args.output: with open(args.output, "w") as f: json.dump(results, f, indent=2) print(f"âœ“ Saved report to {args.output}") print("=" * 70) print(" IAA computation complete!") print("=" * 70) return 0 if __name__ == "__main__": import sys sys.exit(main())