#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # dependencies = [ # "pandas>=2.0.0", # "sentence-transformers>=2.2.0", # ] # /// """ Create Oracle text embeddings for cards. Uses sentence transformers to embed card Oracle text for semantic similarity. """ from __future__ import annotations import argparse import json import pickle from pathlib import Path from typing import Any try: import pandas as pd try: from ml.similarity.text_embeddings import CardTextEmbedder, get_text_embedder HAS_DEPS = True USE_EXISTING = True except ImportError: try: from sentence_transformers import SentenceTransformer HAS_DEPS = True USE_EXISTING = False except ImportError: HAS_DEPS = False USE_EXISTING = False if not USE_EXISTING: class CardTextEmbedder: """Embeds card Oracle text for semantic similarity.""" def __init__(self, model_name: str = "all-MiniLM-L6-v2"): """Initialize text embedder.""" if not HAS_DEPS: raise ImportError("sentence-transformers required") self.model = SentenceTransformer(model_name) self.embeddings: dict[str, Any] = {} def embed_card(self, oracle_text: str) -> Any: """Embed a single card's Oracle text.""" if not oracle_text or pd.isna(oracle_text): return None return self.model.encode(oracle_text, convert_to_numpy=True) def similarity(self, text1: str, text2: str) -> float: """Compute similarity between two texts.""" if not text1 or not text2 or pd.isna(text1) or pd.isna(text2): return 0.0 emb1 = self.model.encode(text1, convert_to_numpy=True) emb2 = self.model.encode(text2, convert_to_numpy=True) # Cosine similarity from numpy import dot from numpy.linalg import norm return float(dot(emb1, emb2) / (norm(emb1) * norm(emb2))) def load_from_csv(self, csv_path: Path, name_col: str = "name", text_col: str = "oracle_text"): """Load cards from CSV and embed Oracle text.""" if not HAS_DEPS: return print(f"Loading cards from {csv_path}...") df = pd.read_csv(csv_path) print(f" Loaded {len(df)} cards") print("Embedding Oracle text...") for idx, row in df.iterrows(): if idx % 1000 == 0: print(f" Progress: {idx}/{len(df)}") card_name = str(row[name_col]) oracle_text = str(row.get(text_col, "")) if oracle_text and not pd.isna(oracle_text) and oracle_text != "nan": self.embeddings[card_name] = self.embed_card(oracle_text) print(f" Embedded {len(self.embeddings)} cards") def save(self, output_path: Path): """Save embeddings to file.""" with open(output_path, "wb") as f: pickle.dump(self.embeddings, f) print(f" Saved embeddings to {output_path}") @classmethod def load(cls, input_path: Path): """Load embeddings from file.""" embedder = cls() with open(input_path, "rb") as f: embedder.embeddings = pickle.load(f) print(f" Loaded {len(embedder.embeddings)} embeddings from {input_path}") return embedder def main() -> int: """Create Oracle text embeddings.""" parser = argparse.ArgumentParser(description="Create Oracle text embeddings") parser.add_argument("--csv", type=str, required=True, help="Card attributes CSV") parser.add_argument("--output", type=str, required=True, help="Output pickle file") parser.add_argument("--model", type=str, default="all-MiniLM-L6-v2", help="Sentence transformer model") args = parser.parse_args() if not HAS_DEPS: print("Error: Missing dependencies: pip install sentence-transformers") return 1 csv_path = Path(args.csv) if not csv_path.exists(): print(f"Error: CSV not found: {csv_path}") return 1 if USE_EXISTING: # Use existing CardTextEmbedder print(f"Using existing CardTextEmbedder with model: {args.model}") embedder = get_text_embedder(model_name=args.model) # Load and embed cards print(f"Loading cards from {csv_path}...") import pandas as pd df = pd.read_csv(csv_path) print(f" Loaded {len(df)} cards") print("Embedding Oracle text...") embedded_count = 0 for idx, row in df.iterrows(): if idx % 1000 == 0: print(f" Progress: {idx}/{len(df)}") card_name = str(row["name"]) oracle_text = str(row.get("oracle_text", "")) if oracle_text and not pd.isna(oracle_text) and oracle_text != "nan": card_dict = { "name": card_name, "oracle_text": oracle_text, "type": str(row.get("type", "")), } embedder.embed_card(card_dict) # This will cache it embedded_count += 1 print(f" Embedded {embedded_count} cards") embedder.save_cache() output_path = Path(args.output) output_path.parent.mkdir(parents=True, exist_ok=True) # Save a note that we're using the existing embedder with open(output_path, "w") as f: f.write(f"# Using existing CardTextEmbedder cache\n") f.write(f"# Cache location: {embedder.cache_dir}\n") f.write(f"# Model: {args.model}\n") f.write(f"# Embedded: {embedded_count} cards\n") else: print(f"Initializing text embedder with model: {args.model}") embedder = CardTextEmbedder(model_name=args.model) embedder.load_from_csv(csv_path) output_path = Path(args.output) output_path.parent.mkdir(parents=True, exist_ok=True) embedder.save(output_path) return 0 if __name__ == "__main__": import sys sys.exit(main())