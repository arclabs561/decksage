#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # dependencies = [ # "pandas>=2.0.0", # ] # /// """ Create test data for downstream task evaluation: 1. Deck completion test decks (partial decks) 2. Card substitution test pairs 3. Contextual discovery test queries """ from __future__ import annotations import argparse import json import random from pathlib import Path from typing import Any try: import pandas as pd HAS_PANDAS = True except ImportError: HAS_PANDAS = False def create_deck_completion_test_decks( game: str, pairs_csv: Path, output_path: Path, num_decks: int = 20, min_cards: int = 20, max_cards: int = 40, ) -> None: """Create test decks for deck completion evaluation.""" if not HAS_PANDAS: print("Error: pandas required") return print(f"Creating {num_decks} test decks for {game}...") # Load pairs to get card names df = pd.read_csv(pairs_csv, nrows=10000) # Sample all_cards = set(df["NAME_1"].unique()) | set(df["NAME_2"].unique()) # Determine partition name if game == "magic": partition_name = "Main" elif game == "yugioh": partition_name = "Main Deck" else: # pokemon partition_name = "Main Deck" test_decks = [] for i in range(num_decks): # Create partial deck (missing cards) num_cards = random.randint(min_cards, max_cards) deck_cards = random.sample(list(all_cards), num_cards) deck = { "deck_id": f"test_{game}_{i}", "game": game, "format": "Modern" if game == "magic" else None, "partitions": [{ "name": partition_name, "cards": [{"name": card, "count": random.randint(1, 4)} for card in deck_cards] }] } test_decks.append(deck) # Save as JSONL with open(output_path, "w") as f: for deck in test_decks: f.write(json.dumps(deck) + "\n") print(f" Created {len(test_decks)} test decks") def create_substitution_test_pairs( game: str, test_set_path: Path, output_path: Path, num_pairs: int = 50, ) -> None: """Create test pairs for card substitution evaluation.""" # Load test set to get query-relevant pairs with open(test_set_path) as f: data = json.load(f) queries = data.get("queries", data) if isinstance(data, dict) else data test_pairs = [] for query, labels in queries.items(): # Get highly relevant cards as substitution targets highly_relevant = labels.get("highly_relevant", []) relevant = labels.get("relevant", []) # Create pairs: (query, target) where target should be substitutable for target in (highly_relevant + relevant)[:3]: # Up to 3 pairs per query test_pairs.append((query, target)) if len(test_pairs) >= num_pairs: break if len(test_pairs) >= num_pairs: break # Save as JSON with open(output_path, "w") as f: json.dump(test_pairs, f, indent=2) print(f" Created {len(test_pairs)} substitution test pairs") def create_contextual_discovery_queries( game: str, test_set_path: Path, output_path: Path, ) -> None: """Create test queries for contextual discovery.""" # Load test set with open(test_set_path) as f: data = json.load(f) queries = data.get("queries", data) if isinstance(data, dict) else data discovery_queries = [] for query, labels in queries.items(): # Extract metadata if available use_case = labels.get("use_case") format_name = labels.get("format") archetype = labels.get("archetype") expected_synergies = labels.get("highly_relevant", []) + labels.get("relevant", []) discovery_queries.append({ "card": query, "format": format_name, "archetype": archetype, "use_case": use_case, "expected_synergies": expected_synergies[:10], # Top 10 }) # Save as JSON with open(output_path, "w") as f: json.dump(discovery_queries, f, indent=2) print(f" Created {len(discovery_queries)} contextual discovery queries") def main() -> int: """Create downstream test data.""" parser = argparse.ArgumentParser(description="Create downstream test data") parser.add_argument("--game", type=str, required=True, choices=["magic", "pokemon", "yugioh"], help="Game to create test data for") parser.add_argument("--pairs-csv", type=str, required=True, help="Pairs CSV for card names") parser.add_argument("--test-set", type=str, required=True, help="Test set JSON") parser.add_argument("--output-dir", type=str, default="experiments/downstream_tests", help="Output directory") args = parser.parse_args() output_dir = Path(args.output_dir) output_dir.mkdir(parents=True, exist_ok=True) pairs_path = Path(args.pairs_csv) test_set_path = Path(args.test_set) if not pairs_path.exists(): print(f"Error: Pairs CSV not found: {pairs_path}") return 1 if not test_set_path.exists(): print(f"Error: Test set not found: {test_set_path}") return 1 # Create deck completion test decks decks_path = output_dir / f"deck_completion_{args.game}.jsonl" create_deck_completion_test_decks( game=args.game, pairs_csv=pairs_path, output_path=decks_path, num_decks=20, ) # Create substitution test pairs subs_path = output_dir / f"substitution_{args.game}.json" create_substitution_test_pairs( game=args.game, test_set_path=test_set_path, output_path=subs_path, num_pairs=50, ) # Create contextual discovery queries contextual_path = output_dir / f"contextual_{args.game}.json" create_contextual_discovery_queries( game=args.game, test_set_path=test_set_path, output_path=contextual_path, ) print(f"\n All test data created in {output_dir}") return 0 if __name__ == "__main__": import sys sys.exit(main())
