#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # dependencies = [] # /// """ Convert similarity annotations to substitution pairs for training. This script bridges the gap between LLM similarity annotations and training data. Extracts pairs where is_substitute=True and similarity_score >= threshold. Usage: python -m src.ml.scripts.convert_annotations_to_substitution_pairs \ --input annotations/similarity_annotations_20250103.jsonl \ --output experiments/substitution_pairs_from_annotations.json \ --min-similarity 0.8 """ from __future__ import annotations import argparse import logging import sys from pathlib import Path # Add src to path for imports _script_file = Path(__file__).resolve() _src_dir = _script_file.parent.parent.parent if str(_src_dir) not in sys.path: sys.path.insert(0, str(_src_dir)) from ml.utils.annotation_utils import ( convert_annotations_to_substitution_pairs, load_similarity_annotations, ) from ml.utils.logging_config import setup_script_logging logger = setup_script_logging() def main() -> int: parser = argparse.ArgumentParser( description="Convert similarity annotations to substitution pairs" ) parser.add_argument( "--input", type=Path, required=True, help="Path to similarity annotations JSONL file", ) parser.add_argument( "--output", type=Path, required=True, help="Output path for substitution pairs JSON", ) parser.add_argument( "--min-similarity", type=float, default=0.8, help="Minimum similarity score threshold (0-1, default: 0.8). For hand annotations (YAML), this is converted from relevance scale.", ) parser.add_argument( "--min-relevance", type=int, default=None, help="Minimum relevance threshold (0-4) for hand annotations. If provided, overrides min-similarity for YAML files.", ) parser.add_argument( "--require-substitute", action="store_true", default=True, help="Only include pairs with is_substitute=True (default: True)", ) parser.add_argument( "--no-require-substitute", dest="require_substitute", action="store_false", help="Include all pairs above similarity threshold", ) parser.add_argument( "--stats", action="store_true", help="Print statistics about annotations", ) args = parser.parse_args() if not args.input.exists(): logger.error(f"Input file not found: {args.input}") return 1 # Load and convert logger.info(f"Converting annotations from {args.input}...") pairs = convert_annotations_to_substitution_pairs( annotation_path=args.input, output_path=args.output, min_similarity=args.min_similarity, min_relevance=args.min_relevance, require_substitute_flag=args.require_substitute, ) if not pairs: logger.warning("No substitution pairs extracted") return 1 # Print statistics if requested if args.stats: annotations = load_similarity_annotations(args.input) total = len(annotations) with_substitute = sum(1 for a in annotations if a.get("is_substitute", False)) above_threshold = sum( 1 for a in annotations if a.get("similarity_score", 0.0) >= args.min_similarity ) functional = sum( 1 for a in annotations if a.get("similarity_type") == "functional" ) logger.info("\n" + "=" * 60) logger.info("ANNOTATION STATISTICS") logger.info("=" * 60) logger.info(f"Total annotations: {total}") logger.info(f"With is_substitute=True: {with_substitute} ({with_substitute/total*100:.1f}%)") logger.info( f"Above similarity threshold ({args.min_similarity}): {above_threshold} ({above_threshold/total*100:.1f}%)" ) logger.info(f"Functional similarity type: {functional} ({functional/total*100:.1f}%)") logger.info(f"Extracted substitution pairs: {len(pairs)}") logger.info("=" * 60) logger.info(f" Successfully converted {len(pairs)} substitution pairs") logger.info(f" Saved to {args.output}") return 0 if __name__ == "__main__": sys.exit(main())
