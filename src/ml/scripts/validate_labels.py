#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # /// """ Post-processing validation for generated labels. Validates: 1. No cross-game contamination 2. No duplicate cards across categories 3. Card name validation (optional, requires card database) """ import json import logging from pathlib import Path from typing import Any from ml.utils.logging_config import setup_script_logging logger = setup_script_logging() # Import card database import sys from pathlib import Path as P script_dir = P(__file__).parent src_dir = script_dir.parent.parent if str(src_dir) not in sys.path: sys.path.insert(0, str(src_dir)) try: from ml.data.card_database import get_card_database HAS_CARD_DB = True except ImportError: HAS_CARD_DB = False logger.warning("Card database not available, falling back to heuristics") def detect_game_from_query(query: str, test_set_data: dict[str, Any] | None = None) -> str: """Detect game from test set metadata (explicit field required).""" if test_set_data: # Check explicit game field (required) if "game" in test_set_data: game = test_set_data["game"].lower() if game in ["magic", "pokemon", "yugioh"]: return game logger.warning(f"Invalid game field: {game}, defaulting to magic") # Fallback: check version string if "version" in test_set_data: version = test_set_data["version"].lower() if "pokemon" in version or "pkm" in version: return "pokemon" if "yugioh" in version or "ygo" in version: return "yugioh" # Check file path as last resort # This should not be needed if metadata is correct logger.warning("No explicit game field found, using path heuristics (not recommended)") return "magic" # Default def validate_labels( test_set_path: Path, output_path: Path | None = None, game: str | None = None, ) -> dict[str, Any]: """ Validate labels in a test set. Returns validation report with issues found. """ logger.info(f"Validating labels in {test_set_path}") with open(test_set_path) as f: data = json.load(f) queries = data.get("queries", data) if isinstance(data, dict) else data # Detect game if not provided if not game: game = detect_game_from_query("", data) logger.info(f"Detected game: {game}") issues = { "cross_game_contamination": [], "duplicate_cards": [], "contradictions": [], "total_queries": len(queries), "queries_with_issues": 0, } # Use card database if available if HAS_CARD_DB: card_db = get_card_database() logger.info("Using card database for validation") else: card_db = None logger.warning("Card database not available, using heuristics (less accurate)") for query_name, query_data in queries.items(): if not isinstance(query_data, dict): continue query_issues = [] # Check for cross-game contamination all_cards = [] for level in ["highly_relevant", "relevant", "somewhat_relevant", "marginally_relevant", "irrelevant"]: all_cards.extend(query_data.get(level, [])) for card in all_cards: if card_db: # Use real card database card_game = card_db.get_game(card) if card_game and card_game != game: query_issues.append(f"Cross-game: {card} (belongs to {card_game}, not {game})") elif card_game is None: # Card not found in any database - might be invalid name query_issues.append(f"Unknown card: {card} (not found in any card database)") else: # Fallback to heuristics (less accurate) if game == "magic": card_game = card_db.get_game(card) if card_db else None if card_game and card_game != "magic": query_issues.append(f"Cross-game: {card} (belongs to {card_game}, not magic)") # Similar for other games... # Check for duplicates across categories card_to_levels = {} for level in ["highly_relevant", "relevant", "somewhat_relevant", "marginally_relevant", "irrelevant"]: for card in query_data.get(level, []): if card not in card_to_levels: card_to_levels[card] = [] card_to_levels[card].append(level) for card, levels in card_to_levels.items(): if len(levels) > 1: query_issues.append(f"Duplicate: {card} appears in {levels}") # Check for contradictions (same card in conflicting levels) level_priority = { "highly_relevant": 4, "relevant": 3, "somewhat_relevant": 2, "marginally_relevant": 1, "irrelevant": 0, } for card, levels in card_to_levels.items(): if len(levels) > 1: # Check if levels are contradictory (e.g., highly_relevant and irrelevant) priority_values = [level_priority[l] for l in levels] if max(priority_values) - min(priority_values) >= 3: query_issues.append(f"Contradiction: {card} in {levels} (conflicting levels)") if query_issues: issues["queries_with_issues"] += 1 if any("Cross-game" in i for i in query_issues): issues["cross_game_contamination"].append({ "query": query_name, "issues": [i for i in query_issues if "Cross-game" in i], }) if any("Duplicate" in i for i in query_issues): issues["duplicate_cards"].append({ "query": query_name, "issues": [i for i in query_issues if "Duplicate" in i], }) if any("Contradiction" in i for i in query_issues): issues["contradictions"].append({ "query": query_name, "issues": [i for i in query_issues if "Contradiction" in i], }) # Fix issues if output path provided if output_path and (issues["cross_game_contamination"] or issues["duplicate_cards"] or issues["contradictions"]): logger.info("Fixing issues...") fixed_data = data.copy() if isinstance(data, dict) else {"queries": data} fixed_queries = fixed_data.get("queries", fixed_data) for query_name, query_data in list(fixed_queries.items()): if not isinstance(query_data, dict): continue # Remove cross-game cards using card database if HAS_CARD_DB: card_db = get_card_database() else: card_db = None cleaned_levels = {} for level in ["highly_relevant", "relevant", "somewhat_relevant", "marginally_relevant", "irrelevant"]: cards = query_data.get(level, []) if card_db: # Use card database to filter valid_cards, invalid_cards = card_db.filter_cards_by_game(cards, game) for invalid_card in invalid_cards: logger.warning(f"Removing cross-game card: {invalid_card} from {query_name}") cleaned_levels[level] = valid_cards else: # Fallback: keep all (can't validate without database) cleaned_levels[level] = cards # Fix duplicates: keep card in highest relevance level only level_priority = { "highly_relevant": 4, "relevant": 3, "somewhat_relevant": 2, "marginally_relevant": 1, "irrelevant": 0, } card_to_best_level = {} for level in ["highly_relevant", "relevant", "somewhat_relevant", "marginally_relevant", "irrelevant"]: for card in cleaned_levels[level]: if card not in card_to_best_level: card_to_best_level[card] = level else: # Keep highest priority level if level_priority[level] > level_priority[card_to_best_level[card]]: card_to_best_level[card] = level # Rebuild levels final_levels = { "highly_relevant": [], "relevant": [], "somewhat_relevant": [], "marginally_relevant": [], "irrelevant": [], } for card, level in card_to_best_level.items(): final_levels[level].append(card) # Update query data for level in final_levels: query_data[level] = final_levels[level] fixed_queries[query_name] = query_data # Save fixed version output_path.parent.mkdir(parents=True, exist_ok=True) with open(output_path, "w") as f: json.dump(fixed_data, f, indent=2) logger.info(f" Fixed labels saved to {output_path}") return issues def main(): """CLI for label validation.""" import argparse parser = argparse.ArgumentParser(description="Validate generated labels") parser.add_argument("--input", type=str, required=True, help="Input test set JSON") parser.add_argument("--output", type=str, help="Output fixed test set JSON (optional)") parser.add_argument("--game", type=str, choices=["magic", "pokemon", "yugioh"], help="Game name (auto-detected if not provided)") args = parser.parse_args() issues = validate_labels( Path(args.input), Path(args.output) if args.output else None, args.game, ) print("\n=== Validation Report ===") print(f"Total queries: {issues['total_queries']}") print(f"Queries with issues: {issues['queries_with_issues']}") print(f"\nCross-game contamination: {len(issues['cross_game_contamination'])} queries") print(f"Duplicate cards: {len(issues['duplicate_cards'])} queries") print(f"Contradictions: {len(issues['contradictions'])} queries") if issues['cross_game_contamination']: print("\nCross-game contamination examples:") for item in issues['cross_game_contamination'][:5]: print(f" {item['query']}: {item['issues'][:2]}") if issues['duplicate_cards']: print("\nDuplicate card examples:") for item in issues['duplicate_cards'][:5]: print(f" {item['query']}: {item['issues'][:2]}") return 0 if issues['queries_with_issues'] == 0 else 1 if __name__ == "__main__": import sys sys.exit(main())