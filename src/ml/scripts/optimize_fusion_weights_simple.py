#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # dependencies = [ # "pandas>=2.0.0", # "numpy<2.0.0", # "gensim>=4.3.0", # ] # /// """ Simple fusion weight optimization based on signal performance. Uses measured signal performance to generate optimal weights: - Embedding: P@10 = 0.1429 (strongest) - Jaccard: P@10 = 0.0833 (weaker) Strategy: Proportional weights based on performance ratio. """ from __future__ import annotations import argparse import json from pathlib import Path try: import pandas as pd import numpy as np from gensim.models import KeyedVectors HAS_DEPS = True except ImportError as e: HAS_DEPS = False print(f"Missing dependencies: {e}") def load_signal_performance(performance_file: Path) -> dict[str, float]: """Load individual signal performance.""" with open(performance_file) as f: data = json.load(f) results = {} for signal, metrics in data.get("results", {}).items(): if "error" not in metrics: results[signal] = metrics.get("p@10", 0.0) return results def proportional_weights(signal_performance: dict[str, float]) -> dict[str, float]: """Generate weights proportional to signal performance.""" total = sum(signal_performance.values()) if total == 0: # Fallback: equal weights return {k: 1.0 / len(signal_performance) for k in signal_performance.keys()} weights = {k: v / total for k, v in signal_performance.items()} return weights def main() -> int: """Optimize fusion weights based on signal performance.""" parser = argparse.ArgumentParser(description="Optimize fusion weights") parser.add_argument( "--signal-performance", type=str, default="experiments/individual_signal_performance.json", help="Signal performance JSON file", ) parser.add_argument( "--output", type=str, default="experiments/optimized_fusion_weights.json", help="Output JSON file", ) args = parser.parse_args() if not HAS_DEPS: print("Error: Missing dependencies") return 1 print("=" * 70) print("Optimize Fusion Weights (Simple)") print("=" * 70) print() # Load signal performance perf_file = Path(args.signal_performance) if not perf_file.exists(): print(f"Error: Signal performance file not found: {perf_file}") print(" Run: uv run --script src/ml/scripts/measure_individual_signals.py") return 1 signal_perf = load_signal_performance(perf_file) print(" Signal Performance:") for signal, p10 in signal_perf.items(): print(f" {signal}: P@10 = {p10:.4f}") print() # Generate proportional weights base_weights = proportional_weights(signal_perf) print("üìê Optimized Weights (proportional to performance):") for signal, weight in base_weights.items(): print(f" {signal}: {weight:.4f}") print() # Map to fusion weight format fusion_weights = { "embed": base_weights.get("embedding", 0.0), "jaccard": base_weights.get("jaccard", 0.0), "functional": base_weights.get("functional", 0.0), } # Normalize to sum to 1.0 total = sum(fusion_weights.values()) if total > 0: fusion_weights = {k: v / total for k, v in fusion_weights.items()} print("üìê Fusion Weights (for WeightedLateFusion):") print(f" embed: {fusion_weights['embed']:.4f}") print(f" jaccard: {fusion_weights['jaccard']:.4f}") print(f" functional: {fusion_weights['functional']:.4f}") print() # Save results output_path = Path(args.output) output_path.parent.mkdir(parents=True, exist_ok=True) with open(output_path, "w") as f: json.dump({ "signal_performance": signal_perf, "proportional_weights": base_weights, "fusion_weights": fusion_weights, "recommendation": { "embed": fusion_weights["embed"], "jaccard": fusion_weights["jaccard"], "functional": fusion_weights["functional"], }, "rationale": "Weights proportional to individual signal P@10 performance", }, f, indent=2) print(f" Results saved to {output_path}") print() print(" Next steps:") print(" 1. Update fusion weights in API/config") print(" 2. Test new weights on test set") print(" 3. Compare to embedding alone (0.1429) and current fusion (0.0882)") return 0 if __name__ == "__main__": import sys sys.exit(main())