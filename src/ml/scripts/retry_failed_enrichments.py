#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # dependencies = [ # "pandas>=2.0.0", # "requests>=2.31.0", # ] # /// """ Retry failed card enrichments with improved name matching. Uses: - Name normalization - Fuzzy matching - Alternative name formats - Multiple retry strategies """ from __future__ import annotations import argparse import logging import re import time from pathlib import Path from typing import Any from ..utils.logging_config import setup_script_logging try: import pandas as pd import requests HAS_DEPS = True except ImportError as e: HAS_DEPS = False print(f"Missing dependencies: {e}") logger = setup_script_logging() SCRYFALL_API = "https://api.scryfall.com" MIN_DELAY = 0.05 MAX_DELAY = 0.2 ADAPTIVE_DELAY = 0.1 def normalize_card_name(name: str) -> str: """Normalize card name for better matching.""" # Remove extra whitespace normalized = re.sub(r'\s+', ' ', name.strip()) # Remove special formatting but keep essential characters normalized = re.sub(r'[^\w\s\-\'\,]', '', normalized) return normalized def get_name_variants(card_name: str) -> list[str]: """Generate name variants to try.""" variants = [card_name] # Original with normalization normalized = normalize_card_name(card_name) if normalized != card_name: variants.append(normalized) # Remove parenthetical content (e.g., "Card Name (Set Name)") no_parens = re.sub(r'\s*\([^)]*\)', '', card_name).strip() if no_parens != card_name and no_parens: variants.append(no_parens) # Remove "//" split cards (take first part, then second part) if '//' in card_name: parts = [p.strip() for p in card_name.split('//')] if parts[0]: variants.append(parts[0]) if len(parts) > 1 and parts[1]: variants.append(parts[1]) # Try removing special Unicode characters (keep ASCII only) ascii_only = ''.join(c for c in card_name if ord(c) < 128) if ascii_only != card_name and ascii_only.strip(): variants.append(ascii_only.strip()) # Try removing common suffixes/prefixes for suffix in [' (minigame)', ' (cont\'d)', ' // ']: if suffix in card_name: cleaned = card_name.replace(suffix, '').strip() if cleaned: variants.append(cleaned) # Remove trailing punctuation cleaned = card_name.rstrip('.,;:!?') if cleaned != card_name and cleaned: variants.append(cleaned) # Deduplicate while preserving order seen = set() unique_variants = [] for v in variants: if v and v not in seen: seen.add(v) unique_variants.append(v) return unique_variants def get_card_from_scryfall_with_retries( card_name: str, delay: float = ADAPTIVE_DELAY, max_retries: int = 3, ) -> tuple[dict[str, Any] | None, float]: """Get card data with multiple retry strategies.""" variants = get_name_variants(card_name) for attempt, variant in enumerate(variants[:max_retries]): if attempt > 0: time.sleep(delay * 0.5) # Shorter delay for retries try: # Try exact match url = f"{SCRYFALL_API}/cards/named" params = {"exact": variant, "format": "json"} response = requests.get(url, params=params, timeout=10) if response.status_code == 200: return response.json(), delay # Try fuzzy if exact fails if response.status_code == 404: time.sleep(delay * 0.3) params = {"fuzzy": variant, "format": "json"} response = requests.get(url, params=params, timeout=10) if response.status_code == 200: return response.json(), delay # Handle rate limiting if response.status_code == 429: retry_after = response.headers.get("Retry-After") if retry_after: try: new_delay = float(retry_after) + 0.1 logger.warning(f"Rate limited, waiting {new_delay:.3f}s") time.sleep(new_delay) continue except ValueError: pass delay = min(MAX_DELAY, delay * 1.5) time.sleep(delay) continue except requests.exceptions.Timeout: delay = min(MAX_DELAY, delay * 1.2) continue except Exception as e: logger.debug(f"Error fetching {variant}: {e}") continue return None, delay def extract_attributes_from_scryfall(card_data: dict[str, Any]) -> dict[str, Any]: """Extract attributes from Scryfall card data.""" colors = "".join(card_data.get("colors", [])) mana_cost = card_data.get("mana_cost", "") cmc = float(card_data.get("cmc", 0.0)) type_line = card_data.get("type_line", "") rarity = card_data.get("rarity", "").lower() power = card_data.get("power") toughness = card_data.get("toughness") set_code = card_data.get("set", "") set_name = card_data.get("set_name", "") oracle_text = card_data.get("oracle_text", "") keywords = card_data.get("keywords", []) return { "type": type_line, "colors": colors, "mana_cost": mana_cost, "cmc": cmc, "rarity": rarity, "power": str(power) if power else "", "toughness": str(toughness) if toughness else "", "set": set_code, "set_name": set_name, "oracle_text": oracle_text, "keywords": ",".join(keywords) if keywords else "", } def retry_failed_enrichments( input_csv: Path, output_csv: Path, max_retries: int = 3, ) -> None: """Retry enrichment for failed cards.""" logger.info(f"Loading attributes from {input_csv}...") df = pd.read_csv(input_csv, dtype=str) # Find failed cards failed_mask = df["type"].isna() | (df["type"] == "") | (df["type"] == "nan") failed_indices = df[failed_mask].index.tolist() logger.info(f"Found {len(failed_indices)} failed cards to retry") if not failed_indices: logger.info(" No failed cards to retry!") return enriched = 0 still_failed = 0 current_delay = ADAPTIVE_DELAY for idx in failed_indices: card_name = df.at[idx, "name"] logger.info(f"Retrying: {card_name}") card_data, current_delay = get_card_from_scryfall_with_retries( card_name, current_delay, max_retries ) if card_data: attrs = extract_attributes_from_scryfall(card_data) df.at[idx, "type"] = str(attrs["type"]) df.at[idx, "colors"] = str(attrs["colors"]) df.at[idx, "mana_cost"] = str(attrs["mana_cost"]) df.at[idx, "cmc"] = str(attrs["cmc"]) df.at[idx, "rarity"] = str(attrs["rarity"]) if "power" in df.columns: df.at[idx, "power"] = attrs.get("power", "") if "toughness" in df.columns: df.at[idx, "toughness"] = attrs.get("toughness", "") if "set" in df.columns: df.at[idx, "set"] = attrs.get("set", "") if "set_name" in df.columns: df.at[idx, "set_name"] = attrs.get("set_name", "") enriched += 1 logger.info(f" Enriched: {card_name}") else: still_failed += 1 logger.warning(f" Error: Still failed: {card_name}") # Save periodically if enriched % 10 == 0: df.to_csv(output_csv, index=False) logger.info(f" ðŸ’¾ Progress saved ({enriched} retried successfully)") # Final save df.to_csv(output_csv, index=False) logger.info(f" Retry complete!") logger.info(f" Successfully enriched: {enriched}") logger.info(f" Still failed: {still_failed}") logger.info(f" Success rate: {100*enriched/(enriched+still_failed):.1f}%" if (enriched+still_failed) > 0 else "N/A") def main() -> int: """Retry failed enrichments.""" parser = argparse.ArgumentParser(description="Retry failed card enrichments") parser.add_argument("--input", type=str, required=True, help="Input attributes CSV") parser.add_argument("--output", type=str, help="Output CSV (default: same as input)") parser.add_argument("--max-retries", type=int, default=3, help="Max retry attempts per card") args = parser.parse_args() if not HAS_DEPS: logger.error("Missing dependencies") return 1 input_path = Path(args.input) if args.output: output_path = Path(args.output) else: output_path = input_path retry_failed_enrichments(input_path, output_path, args.max_retries) return 0 if __name__ == "__main__": import sys sys.exit(main())