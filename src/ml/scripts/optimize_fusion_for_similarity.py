#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # dependencies = [ # "gensim>=4.0.0", # "numpy>=1.20.0", # "pandas>=1.3.0", # "scipy>=1.10.0", # ] # /// """ Optimize fusion weights for Magic similarity task. Combines: - Game-specific embeddings - Functional+text embeddings - Jaccard co-occurrence Uses Bayesian optimization to find optimal weights. """ from __future__ import annotations import argparse import json import logging from pathlib import Path import numpy as np import pandas as pd from gensim.models import KeyedVectors from scipy.optimize import minimize from ml.utils.logging_config import setup_script_logging logger = setup_script_logging() # Add src to path import sys script_dir = Path(__file__).parent src_dir = script_dir.parent.parent if str(src_dir) not in sys.path: sys.path.insert(0, str(src_dir)) try: from ml.similarity.fusion import WeightedLateFusion, FusionWeights from ml.utils.name_normalizer import NameMapper HAS_DEPS = True except ImportError as e: logger.error(f"Missing dependencies: {e}") HAS_DEPS = False def load_jaccard_graph(pairs_csv: Path | None = None, graph_db: Path | None = None, game: str | None = None) -> dict[str, set[str]]: """Load co-occurrence graph for Jaccard similarity (uses shared implementation).""" from ml.utils.shared_operations import load_jaccard_graph as shared_load return shared_load(pairs_csv=pairs_csv, graph_db=graph_db, game=game) def evaluate_fusion_with_weights( weights: np.ndarray, magic_gs: KeyedVectors, ft_emb: KeyedVectors, jaccard_graph: dict[str, set[str]], test_set: dict, name_mapper: NameMapper | None, ) -> float: """Evaluate fusion with given weights. Returns -P@10 (for minimization).""" # Unpack weights w_gs, w_jaccard, w_ft = weights # Normalize total = w_gs + w_jaccard + w_ft if total <= 0: return 1.0 # Bad weights w_gs /= total w_jaccard /= total w_ft /= total # Create fusion weights fusion_weights = FusionWeights( embed=w_gs, jaccard=w_jaccard, text_embed=w_ft, ) # Create a wrapper that combines both embeddings # For now, use game-specific as primary, functional+text as text_embedder # We'll need to create a combined embedding or use text_embedder # Simple approach: use game-specific as primary embedding # and create a wrapper for functional+text if needed # For optimization, we'll use game-specific and handle functional+text via weights # For optimization, we need to combine embeddings manually # Create a simple wrapper that averages both embeddings class CombinedEmbedding: def __init__(self, emb1, emb2, w1, w2): self.emb1 = emb1 self.emb2 = emb2 self.w1 = w1 self.w2 = w2 self.key_to_index = emb1.key_to_index def __contains__(self, key): return key in self.emb1 or key in self.emb2 def similarity(self, a, b): s1 = self.emb1.similarity(a, b) if a in self.emb1 and b in self.emb1 else 0.0 s2 = self.emb2.similarity(a, b) if a in self.emb2 and b in self.emb2 else 0.0 return self.w1 * s1 + self.w2 * s2 def most_similar(self, query, topn=10): # Get from both and combine r1 = self.emb1.most_similar(query, topn=topn*2) if query in self.emb1 else [] r2 = self.emb2.most_similar(query, topn=topn*2) if query in self.emb2 else [] # Combine and re-rank combined = {} for card, score in r1: combined[card] = combined.get(card, 0) + self.w1 * score for card, score in r2: combined[card] = combined.get(card, 0) + self.w2 * score return sorted(combined.items(), key=lambda x: x[1], reverse=True)[:topn] # Create combined embedding combined_emb = CombinedEmbedding(magic_gs, ft_emb, w_gs, w_ft) # Create fusion fusion = WeightedLateFusion( embeddings=combined_emb, # Combined embedding adj=jaccard_graph, # Jaccard graph weights=FusionWeights(embed=1.0, jaccard=w_jaccard, functional=0.0, text_embed=0.0), ) # Evaluate try: # Direct evaluation scores = [] for query, labels in test_set.items(): try: preds = fusion.similar(query, k=10) if not preds: continue pred_cards = [p[0] if isinstance(p, tuple) else p for p in preds] relevant = labels.get('highly_relevant', []) + labels.get('relevant', []) if isinstance(labels, dict) else (labels if isinstance(labels, list) else []) if not relevant: continue hits = sum(1 for c in pred_cards[:10] if c in relevant) scores.append(hits / min(10, len(relevant))) except: continue p10 = sum(scores) / len(scores) if scores else 0.0 return -p10 # Negative for minimization except Exception as e: logger.warning(f"Evaluation error: {e}") return 1.0 def optimize_weights( magic_gs: KeyedVectors, ft_emb: KeyedVectors, jaccard_graph: dict[str, set[str]], test_set: dict, name_mapper: NameMapper | None, ) -> dict[str, Any]: """Optimize fusion weights using scipy.optimize.""" logger.info("Optimizing fusion weights...") # Initial guess: equal weights initial_weights = np.array([0.33, 0.33, 0.34]) # Bounds: all weights >= 0 bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 1.0)] # Optimize result = minimize( evaluate_fusion_with_weights, initial_weights, args=(magic_gs, ft_emb, jaccard_graph, test_set, name_mapper), method="SLSQP", bounds=bounds, options={"maxiter": 50, "ftol": 1e-6}, ) if result.success: best_weights = result.x best_p10 = -result.fun # Normalize total = sum(best_weights) best_weights = best_weights / total return { "success": True, "weights": { "game_specific": float(best_weights[0]), "jaccard": float(best_weights[1]), "functional_text": float(best_weights[2]), }, "p@10": float(best_p10), } else: logger.warning(f"Optimization failed: {result.message}") return { "success": False, "message": result.message, } def main() -> int: parser = argparse.ArgumentParser(description="Optimize fusion for similarity") parser.add_argument("--test-set", type=Path, required=True, help="Test set JSON") parser.add_argument("--output", type=Path, required=True, help="Output JSON") from ml.utils.paths import PATHS parser.add_argument("--magic-gs", type=Path, default=PATHS.embeddings / "magic_game_specific.wv", help="Magic game-specific embedding") parser.add_argument("--functional-text", type=Path, default=PATHS.embeddings / "trained_functional_text.wv", help="Functional+text embedding") parser.add_argument("--pairs", type=Path, default=PATHS.pairs_large, help="Pairs CSV for Jaccard") args = parser.parse_args() if not HAS_DEPS: logger.error("Missing dependencies") return 1 # Load embeddings logger.info("Loading embeddings...") magic_gs = KeyedVectors.load(str(args.magic_gs)) ft_emb = KeyedVectors.load(str(args.functional_text)) logger.info(f" Magic GS: {len(magic_gs)} cards") logger.info(f" Functional+text: {len(ft_emb)} cards") # Load Jaccard graph jaccard_graph = load_jaccard_graph(args.pairs) # Load test set logger.info(f"Loading test set from {args.test_set}...") with open(args.test_set) as f: test_data = json.load(f) test_set = test_data.get("queries", test_data) if isinstance(test_data, dict) else test_data logger.info(f" {len(test_set)} queries") # Load name mapper name_mapper = None name_mapping_path = PATHS.experiments / "name_mapping.json" if name_mapping_path.exists(): name_mapper = NameMapper.load_from_file(name_mapping_path) logger.info(" Name mapper loaded") # Optimize result = optimize_weights(magic_gs, ft_emb, jaccard_graph, test_set, name_mapper) # Save results args.output.parent.mkdir(parents=True, exist_ok=True) with open(args.output, "w") as f: json.dump(result, f, indent=2) if result.get("success"): logger.info(f" Optimized weights: {result['weights']}") logger.info(f" P@10: {result['p@10']:.4f}") else: logger.error(f"Error: Optimization failed: {result.get('message')}") return 0 if result.get("success") else 1 if __name__ == "__main__": import sys sys.exit(main())