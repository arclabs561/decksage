#!/usr/bin/env python3 """ Add Format Metadata to Test Set Adds format and archetype metadata to test set queries for better coverage tracking. Part of T0.1 foundation refinement. """ from __future__ import annotations import json import logging from pathlib import Path from typing import Any from ..utils.data_loading import load_decks_jsonl from ..utils.paths import PATHS # Optional: use validators if available try: from ..validation.validators.loader import load_decks_lenient HAS_VALIDATORS = True except ImportError: HAS_VALIDATORS = False load_decks_lenient = None logger = logging.getLogger(__name__) def infer_format_from_decks( card_name: str, game: str, decks: list[dict[str, Any]], ) -> dict[str, int]: """ Infer format distribution for a card from tournament decks. Returns dict mapping format -> count of decks containing card. """ format_counts: dict[str, int] = {} for deck in decks: deck_format = deck.get("format") if not deck_format or deck_format == "Unknown": continue # Check if card is in deck partition_name = "Main" if game == "magic" else "Main Deck" for partition in deck.get("partitions", []): if partition.get("name") == partition_name: for card in partition.get("cards", []): if card.get("name") == card_name: format_counts[deck_format] = format_counts.get(deck_format, 0) + 1 break return format_counts def infer_archetype_from_decks( card_name: str, game: str, decks: list[dict[str, Any]], ) -> dict[str, int]: """ Infer archetype distribution for a card from tournament decks. Returns dict mapping archetype -> count of decks containing card. """ archetype_counts: dict[str, int] = {} for deck in decks: archetype = deck.get("archetype") if not archetype or archetype == "Unknown": continue # Check if card is in deck partition_name = "Main" if game == "magic" else "Main Deck" for partition in deck.get("partitions", []): if partition.get("name") == partition_name: for card in partition.get("cards", []): if card.get("name") == card_name: archetype_counts[archetype] = archetype_counts.get(archetype, 0) + 1 break return archetype_counts def add_metadata_to_test_set( test_set_path: Path, output_path: Path, game: str = "magic", ) -> None: """ Add format and archetype metadata to test set queries. Uses tournament deck data to infer format/archetype for each query card. """ # Load test set with open(test_set_path) as f: test_data = json.load(f) queries = test_data.get("queries", test_data) if isinstance(test_data, dict) else test_data # Load tournament decks logger.info(f"Loading tournament decks for {game}...") try: decks = load_decks_jsonl( jsonl_path=PATHS.decks_with_metadata, formats=None, # Load all formats validate=HAS_VALIDATORS, ) except Exception as e: logger.warning(f"Failed to load decks with validation: {e}, trying without validation") # Fallback: load without validation decks = [] if PATHS.decks_with_metadata.exists(): with open(PATHS.decks_with_metadata) as f: for line in f: if line.strip(): try: deck = json.loads(line) decks.append(deck) except Exception: continue # Filter by game game_decks = [ d for d in decks if d.get("game") == game or (game == "magic" and d.get("game") is None) ] logger.info(f"Loaded {len(game_decks)} tournament decks") # Add metadata to each query updated_count = 0 for query_name, query_data in queries.items(): if not isinstance(query_data, dict): continue # Infer format distribution format_counts = infer_format_from_decks(query_name, game, game_decks) if format_counts: # Use most common format primary_format = max(format_counts.items(), key=lambda x: x[1])[0] query_data["format"] = primary_format query_data["format_distribution"] = format_counts updated_count += 1 # Infer archetype distribution archetype_counts = infer_archetype_from_decks(query_name, game, game_decks) if archetype_counts: # Use most common archetype primary_archetype = max(archetype_counts.items(), key=lambda x: x[1])[0] query_data["archetype"] = primary_archetype query_data["archetype_distribution"] = archetype_counts updated_count += 1 # Save updated test set if isinstance(test_data, dict): test_data["queries"] = queries else: test_data = queries output_path.parent.mkdir(parents=True, exist_ok=True) with open(output_path, "w") as f: json.dump(test_data, f, indent=2) logger.info(f" Added metadata to {updated_count} queries") logger.info(f" Saved to: {output_path}") def main() -> int: """CLI for adding format metadata.""" import argparse parser = argparse.ArgumentParser(description="Add format/archetype metadata to test set") parser.add_argument( "--test-set", type=Path, required=True, help="Path to test set JSON file", ) parser.add_argument( "--output", type=Path, help="Output path (default: overwrite input)", ) parser.add_argument( "--game", type=str, default="magic", choices=["magic", "pokemon", "yugioh"], help="Game name", ) args = parser.parse_args() logging.basicConfig(level=logging.INFO) output_path = args.output or args.test_set add_metadata_to_test_set( test_set_path=args.test_set, output_path=output_path, game=args.game, ) return 0 if __name__ == "__main__": import sys sys.exit(main())
