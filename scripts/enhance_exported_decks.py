#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # dependencies = [] # /// """ Enhance exported decks with all quality improvements. Fixes: 1. Backfill missing source fields 2. Deduplicate decks 3. Normalize card names 4. Filter invalid deck sizes 5. Standardize schema 6. Backfill missing metadata """ from __future__ import annotations import argparse import json import re import sys import unicodedata from collections import defaultdict from html import unescape from pathlib import Path from typing import Any def normalize_card_name(name: str) -> str: """Normalize card name for consistent matching.""" if not name: return "" # Trim whitespace name = name.strip() # Decode HTML entities name = unescape(name) # Unicode normalization (NFC) name = unicodedata.normalize("NFC", name) # Collapse multiple spaces name = " ".join(name.split()) return name def backfill_source_from_url(url: str, deck_id: str) -> str | None: """Backfill source field from URL or deck_id.""" if not url: url = deck_id url_lower = url.lower() # Check URL patterns if "mtgtop8.com" in url_lower or "mtgtop8" in url_lower: return "mtgtop8" elif "mtggoldfish.com" in url_lower or "goldfish" in url_lower: return "goldfish" elif "deckbox.org" in url_lower or "deckbox" in url_lower: return "deckbox" elif "limitlesstcg.com" in url_lower or "limitless" in url_lower: return "limitless-web" elif "ygoprodeck.com" in url_lower or "ygoprodeck" in url_lower: return "ygoprodeck-tournament" elif "scryfall.com" in url_lower: return "scryfall" # Check deck_id patterns if "mtgtop8" in deck_id.lower(): return "mtgtop8" elif "goldfish" in deck_id.lower(): return "goldfish" elif "deckbox" in deck_id.lower(): return "deckbox" elif "limitless" in deck_id.lower(): return "limitless-web" elif "ygoprodeck" in deck_id.lower(): return "ygoprodeck-tournament" return None def is_valid_deck_size(game: str, card_count: int) -> bool: """Check if deck size is valid for the game.""" if card_count <= 0: return False if game == "magic": # Magic: 60-card minimum (Standard/Modern), 100-card (Commander) # Allow 40-200 cards to be safe (covers most formats) return 40 <= card_count <= 200 elif game == "pokemon": # Pokemon: Exactly 60 cards return card_count == 60 elif game == "yugioh": # Yu-Gi-Oh: 40-60 Main Deck, 0-15 Extra, 0-15 Side # Total should be reasonable (40-90 cards) return 40 <= card_count <= 90 else: # Unknown game: allow reasonable range return 20 <= card_count <= 200 def standardize_schema(deck: dict[str, Any]) -> dict[str, Any]: """Standardize deck schema.""" # Ensure placement is int placement = deck.get("placement") if placement is not None: if isinstance(placement, str): try: placement = int(placement) except ValueError: placement = 0 elif not isinstance(placement, int): placement = 0 else: placement = 0 deck["placement"] = placement # Ensure all required fields exist if "game" not in deck: deck["game"] = "unknown" if "deck_id" not in deck: deck["deck_id"] = "" if "archetype" not in deck: deck["archetype"] = "" if "format" not in deck: deck["format"] = "" if "url" not in deck: deck["url"] = "" if "cards" not in deck: deck["cards"] = [] if "source" not in deck: deck["source"] = "" # Normalize card names normalized_cards = [] for card in deck.get("cards", []): if not isinstance(card, dict): continue name = card.get("name", "") if not name or not name.strip(): continue count = card.get("count", 0) if count <= 0: continue normalized_cards.append({ "name": normalize_card_name(name), "count": int(count), "partition": card.get("partition", ""), }) deck["cards"] = normalized_cards return deck def enhance_decks( input_file: Path, output_file: Path, deduplicate: bool = True, filter_invalid: bool = True, ) -> dict[str, Any]: """Enhance decks with all fixes.""" stats = { "total": 0, "duplicates_removed": 0, "invalid_removed": 0, "source_backfilled": 0, "cards_normalized": 0, "final_count": 0, } seen_urls = set() seen_card_sigs = set() enhanced_decks = [] print(f"Reading {input_file}...") with open(input_file) as f: for line_num, line in enumerate(f, 1): if not line.strip(): continue try: deck = json.loads(line) stats["total"] += 1 # Standardize schema deck = standardize_schema(deck) # Backfill source (only if missing - Go tool should have already done this) # This is a fallback for decks exported before Go tool update if not deck.get("source"): source = backfill_source_from_url(deck.get("url", ""), deck.get("deck_id", "")) if source: deck["source"] = source stats["source_backfilled"] += 1 # Count normalized cards if deck.get("cards"): stats["cards_normalized"] += len(deck["cards"]) # Check deck size card_count = sum(c.get("count", 0) for c in deck.get("cards", [])) game = deck.get("game", "unknown") if filter_invalid and not is_valid_deck_size(game, card_count): stats["invalid_removed"] += 1 continue # Deduplicate if deduplicate: url = deck.get("url", "") if url and url in seen_urls: stats["duplicates_removed"] += 1 continue seen_urls.add(url) # Also check card signature card_sig = tuple(sorted( (c.get("name", ""), c.get("count", 0)) for c in deck.get("cards", []) )) if card_sig in seen_card_sigs: stats["duplicates_removed"] += 1 continue seen_card_sigs.add(card_sig) enhanced_decks.append(deck) if line_num % 10000 == 0: print(f" Processed {line_num:,} decks...") except json.JSONDecodeError as e: print(f" Warning: JSON error at line {line_num}: {e}") continue except Exception as e: print(f" Warning: Error at line {line_num}: {e}") continue stats["final_count"] = len(enhanced_decks) # Write enhanced decks print(f"\nWriting {len(enhanced_decks):,} enhanced decks to {output_file}...") output_file.parent.mkdir(parents=True, exist_ok=True) with open(output_file, "w") as f: for deck in enhanced_decks: json.dump(deck, f) f.write("\n") return stats def main() -> int: """Enhance exported decks.""" parser = argparse.ArgumentParser(description="Enhance exported decks with quality fixes") parser.add_argument("--input", type=Path, default=Path("data/processed/decks_all_unified.jsonl"), help="Input file") parser.add_argument("--output", type=Path, default=Path("data/processed/decks_all_enhanced.jsonl"), help="Output file") parser.add_argument("--no-deduplicate", action="store_true", help="Skip deduplication") parser.add_argument("--no-filter", action="store_true", help="Skip invalid deck filtering") args = parser.parse_args() if not args.input.exists(): print(f"Error: Input file not found: {args.input}") return 1 print("=" * 70) print("ENHANCING EXPORTED DECKS") print("=" * 70) stats = enhance_decks( args.input, args.output, deduplicate=not args.no_deduplicate, filter_invalid=not args.no_filter, ) print("\n" + "=" * 70) print("ENHANCEMENT SUMMARY") print("=" * 70) print(f"Total decks processed: {stats['total']:,}") print(f"Duplicates removed: {stats['duplicates_removed']:,}") print(f"Invalid decks removed: {stats['invalid_removed']:,}") print(f"Source fields backfilled: {stats['source_backfilled']:,}") print(f"Cards normalized: {stats['cards_normalized']:,}") print(f"Final deck count: {stats['final_count']:,}") print(f"\n Enhanced decks saved to: {args.output}") return 0 if __name__ == "__main__": sys.exit(main())
