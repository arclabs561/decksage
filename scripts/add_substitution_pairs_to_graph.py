#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # dependencies = [ # "pandas>=2.0.0", # ] # /// """ Add substitution pairs to incremental graph as high-weight edges. This ensures substitution pairs from annotations are included in the graph for GNN training and other graph-based methods. """ from __future__ import annotations import json import logging from pathlib import Path from typing import Any from ml.data.incremental_graph import IncrementalCardGraph from ml.utils.paths import PATHS logging.basicConfig(level=logging.INFO) logger = logging.getLogger(__name__) def add_substitution_pairs_to_graph( graph_path: Path, substitution_pairs: list[tuple[str, str]], substitution_weight: int = 10, # High weight for substitution edges ) -> IncrementalCardGraph: """Add substitution pairs to incremental graph as edges. Args: graph_path: Path to graph (JSON or SQLite) substitution_pairs: List of (card1, card2) tuples substitution_weight: Weight for substitution edges (default: 10, higher than co-occurrence) Returns: Updated graph """ # Load graph use_sqlite = graph_path.suffix == ".db" if graph_path else False graph = IncrementalCardGraph(graph_path, use_sqlite=use_sqlite) logger.info(f"Loaded graph: {len(graph.nodes)} nodes, {len(graph.edges)} edges") # Add substitution pairs as edges added = 0 enhanced = 0 for card1, card2 in substitution_pairs: if not card1 or not card2: continue edge_key = tuple(sorted([card1, card2])) if edge_key in graph.edges: # Enhance existing edge # Handle both int and bytes weight types (SQLite may store as bytes) current_weight = graph.edges[edge_key].weight if isinstance(current_weight, bytes): current_weight = int.from_bytes(current_weight, 'big') elif not isinstance(current_weight, int): current_weight = int(current_weight) graph.edges[edge_key].weight = current_weight + substitution_weight graph.edges[edge_key].metadata["is_substitution"] = True graph.edges[edge_key].metadata["substitution_weight"] = substitution_weight enhanced += 1 else: # Add new edge from datetime import datetime from ml.data.incremental_graph import Edge edge = Edge( card1=edge_key[0], card2=edge_key[1], weight=substitution_weight, first_seen=datetime.now(), last_seen=datetime.now(), metadata={ "is_substitution": True, "substitution_weight": substitution_weight, "source": "annotation", }, ) # Initialize temporal distribution (substitution pairs are current-time judgments) edge.update_temporal(datetime.now(), format=None) # Format unknown for annotation-based pairs graph.edges[edge_key] = edge # Ensure nodes exist if edge_key[0] not in graph.nodes: from ml.data.incremental_graph import CardNode graph.nodes[edge_key[0]] = CardNode(name=edge_key[0]) if edge_key[1] not in graph.nodes: from ml.data.incremental_graph import CardNode graph.nodes[edge_key[1]] = CardNode(name=edge_key[1]) added += 1 # Save graph graph.save() logger.info(f" Added {added} new substitution edges") logger.info(f" Enhanced {enhanced} existing edges with substitution weight") logger.info(f" Graph now has {len(graph.nodes)} nodes, {len(graph.edges)} edges") return graph def main() -> int: """Main entry point.""" import argparse parser = argparse.ArgumentParser(description="Add substitution pairs to incremental graph") parser.add_argument( "--graph", type=Path, default=PATHS.incremental_graph_db, help="Path to graph (JSON or SQLite)", ) parser.add_argument( "--substitution-pairs", type=Path, required=True, help="Path to substitution pairs JSON file", ) parser.add_argument( "--weight", type=int, default=10, help="Weight for substitution edges (default: 10)", ) args = parser.parse_args() # Load substitution pairs with open(args.substitution_pairs) as f: pairs_data = json.load(f) if isinstance(pairs_data, list): substitution_pairs = [(str(p[0]), str(p[1])) for p in pairs_data if len(p) >= 2] else: substitution_pairs = [] logger.warning("Unexpected substitution pairs format") logger.info(f"Loaded {len(substitution_pairs)} substitution pairs") # Add to graph add_substitution_pairs_to_graph( args.graph, substitution_pairs, substitution_weight=args.weight, ) return 0 if __name__ == "__main__": import sys sys.exit(main())