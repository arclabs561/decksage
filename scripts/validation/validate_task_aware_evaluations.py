#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # /// """ Validate that all evaluation functions properly use task-specific instructions. This script checks: 1. All fusion.similar() calls in evaluation functions have task_type 2. All downstream task modules use appropriate task types 3. Task types match their intended use cases """ import ast import re from pathlib import Path from typing import Any def find_fusion_similar_calls(file_path: Path) -> list[dict[str, Any]]: """Find all fusion.similar() calls in a file.""" with open(file_path) as f: content = f.read() # Parse AST try: tree = ast.parse(content) except SyntaxError: return [] calls = [] class Visitor(ast.NodeVisitor): def visit_Call(self, node: ast.Call): # Check if this is a fusion.similar() call if isinstance(node.func, ast.Attribute): if node.func.attr == "similar": # Check if it's on fusion or self.fusion if isinstance(node.func.value, ast.Name): if node.func.value.id in ("fusion", "self"): # Get line number and check for task_type has_task_type = False task_type_value = None for keyword in node.keywords: if keyword.arg == "task_type": has_task_type = True if isinstance(keyword.value, ast.Constant): task_type_value = keyword.value.value elif isinstance(keyword.value, ast.Str): # Python < 3.8 task_type_value = keyword.value.s calls.append({ "line": node.lineno, "has_task_type": has_task_type, "task_type_value": task_type_value, "file": str(file_path), }) self.generic_visit(node) Visitor().visit(tree) return calls def check_evaluation_files() -> dict[str, Any]: """Check all evaluation and downstream task files.""" results = { "files_checked": [], "issues": [], "warnings": [], "valid": [], } # Files to check files_to_check = [ "src/ml/scripts/evaluate_downstream_complete.py", "src/ml/deck_building/deck_refinement.py", "src/ml/deck_building/contextual_discovery.py", "src/ml/deck_building/deck_completion.py", ] for file_path_str in files_to_check: file_path = Path(file_path_str) if not file_path.exists(): results["warnings"].append(f"File not found: {file_path_str}") continue results["files_checked"].append(file_path_str) calls = find_fusion_similar_calls(file_path) for call in calls: if not call["has_task_type"]: # Check if it's in an evaluation function if "evaluate" in file_path_str or "downstream" in file_path_str: results["issues"].append( f"{call['file']}:{call['line']}: fusion.similar() call missing task_type" ) else: # Might be okay if it's in a generic function results["warnings"].append( f"{call['file']}:{call['line']}: fusion.similar() call without task_type (might be intentional)" ) else: results["valid"].append( f"{call['file']}:{call['line']}: fusion.similar() with task_type='{call['task_type_value']}'" ) return results def main() -> int: """Run validation.""" print("=" * 70) print("VALIDATING TASK-AWARE EVALUATIONS") print("=" * 70) print() results = check_evaluation_files() print(f"Files checked: {len(results['files_checked'])}") print(f"Valid calls: {len(results['valid'])}") print(f"Issues: {len(results['issues'])}") print(f"Warnings: {len(results['warnings'])}") print() if results["valid"]: print(" Valid task-aware calls:") for valid in results["valid"][:10]: # Show first 10 print(f" {valid}") if len(results["valid"]) > 10: print(f" ... and {len(results['valid']) - 10} more") print() if results["issues"]: print("Error: Issues found:") for issue in results["issues"]: print(f" {issue}") print() return 1 if results["warnings"]: print("Warning: Warnings:") for warning in results["warnings"][:5]: # Show first 5 print(f" {warning}") if len(results["warnings"]) > 5: print(f" ... and {len(results['warnings']) - 5} more") print() print(" All evaluation functions properly use task-specific instructions!") return 0 if __name__ == "__main__": import sys sys.exit(main())