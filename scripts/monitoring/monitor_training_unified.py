#!/usr/bin/env python3 """Unified training monitoring using structured log parsing. Works with both runctl-managed instances and local training scripts. Parses structured log prefixes ([PROGRESS], [CHECKPOINT], etc.) for reliable monitoring. """ from __future__ import annotations import argparse import sys import time from pathlib import Path # Add src to path for imports sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src")) try: from ml.utils.log_monitor import ( LocalLogMonitor, RunctlLogMonitor, format_status, monitor_training, ) HAS_DEPS = True except ImportError as e: HAS_DEPS = False print(f"Missing dependencies: {e}") def main() -> int: """Main monitoring loop.""" parser = argparse.ArgumentParser(description="Monitor training with structured logs") parser.add_argument( "--instance-id", help="EC2 instance ID (for runctl monitoring)", ) parser.add_argument( "--log-path", type=Path, help="Local log file path (for local monitoring)", ) parser.add_argument( "--interval", type=int, default=30, help="Check interval in seconds (default: 30)", ) parser.add_argument( "--once", action="store_true", help="Check once and exit (don't loop)", ) parser.add_argument( "--use-live-logs", action="store_true", default=True, help="Use live log tailing from instance (default: True)", ) parser.add_argument( "--log-path-on-instance", help="Path to log file on instance (auto-detected if not provided)", ) args = parser.parse_args() if not HAS_DEPS: print("Error: Missing dependencies - cannot monitor") return 1 if not args.instance_id and not args.log_path: parser.error("Either --instance-id or --log-path must be provided") print("=" * 70) print("TRAINING MONITOR - STRUCTURED LOG PARSING") print("=" * 70) if args.instance_id: print(f"Instance: {args.instance_id}") if args.log_path: print(f"Log: {args.log_path}") print(f"Interval: {args.interval}s") print() iteration = 0 while True: iteration += 1 print(f"[{iteration}] {time.strftime('%Y-%m-%d %H:%M:%S')}") print("-" * 70) try: if args.instance_id: from ml.utils.log_monitor import RunctlLogMonitor monitor = RunctlLogMonitor( instance_id=args.instance_id, log_path=args.log_path_on_instance, ) status = monitor.get_status(use_live_logs=args.use_live_logs) elif args.log_path: from ml.utils.log_monitor import LocalLogMonitor monitor = LocalLogMonitor(args.log_path) status = monitor.get_status() else: # Fallback to unified function status = monitor_training( instance_id=args.instance_id, log_path=args.log_path, use_runctl=bool(args.instance_id), check_interval=args.interval, ) print(format_status(status)) if status.is_complete: print() print(" Training complete!") return 0 except Exception as e: print(f"Error: Error monitoring: {e}") import traceback traceback.print_exc() print() if args.once: break print(f"Next check in {args.interval}s...") print() time.sleep(args.interval) return 0 if __name__ == "__main__": sys.exit(main())