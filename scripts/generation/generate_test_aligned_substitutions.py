#!/usr/bin/env python3 # /// script # requires-python = ">=3.11" # dependencies = [ # "pydantic-ai>=0.0.12", # ] # /// """ Generate substitution pairs aligned with test set queries. Improves annotation coverage by focusing on cards that appear in test set queries and their relevant labels. """ from __future__ import annotations import argparse import json import logging import os from collections import Counter from pathlib import Path from typing import Any try: from pydantic_ai import Agent from pydantic import BaseModel, Field HAS_PYDANTIC_AI = True except ImportError: HAS_PYDANTIC_AI = False logging.basicConfig(level=logging.INFO) logger = logging.getLogger(__name__) # Import path fix import sys script_dir = Path(__file__).parent src_dir = script_dir.parent / "src" if str(src_dir) not in sys.path: sys.path.insert(0, str(src_dir)) try: from ml.utils.pydantic_ai_helpers import make_agent, get_default_model from ml.utils.data_loading import load_test_set from ml.utils.paths import PATHS HAS_HELPERS = True except ImportError: HAS_HELPERS = False if HAS_PYDANTIC_AI: class SubstitutionPair(BaseModel): """A pair of functionally substitutable cards.""" original: str = Field(description="Original card name") substitute: str = Field(description="Functional substitute card name") function: str = Field(description="Shared function (e.g., burn, card_selection, removal)") format: str = Field(description="Format where both are legal") reasoning: str = Field(description="Why these are good substitutes") confidence: str = Field(description="Confidence level: high|medium|low") class SubstitutionPairBatch(BaseModel): """Batch of substitution pairs.""" pairs: list[SubstitutionPair] = Field(description="List of substitution pairs") PROMPT = """You are an expert at identifying functionally substitutable cards in TCGs. **Your Task**: Generate pairs of cards where one can functionally substitute for the other in most decks. **Substitution Criteria**: 1. **Same Function**: Cards serve the same role (removal, card draw, ramp, threat, etc.) 2. **Similar Power Level**: Comparable effectiveness in their role 3. **Same Format**: Both legal in the same format (or both banned/restricted) 4. **Substitutability**: Can replace one with the other without major deck changes 5. **Well-Known Cards**: Both cards should be recognizable to players **Examples of Good Substitution Pairs**: - Lightning Bolt → Chain Lightning (both 1-mana red burn) - Brainstorm → Ponder (both blue card selection) - Path to Exile → Swords to Plowshares (both white removal) - Counterspell → Mana Leak (both blue counterspells) - Sol Ring → Mana Crypt (both fast mana artifacts) Generate {num_pairs} high-quality substitution pairs.""" def make_substitution_agent() -> Agent | None: """Create LLM agent for generating substitution pairs.""" if not HAS_PYDANTIC_AI: logger.error("pydantic-ai required") return None try: if HAS_HELPERS: model_name = get_default_model("annotator") provider = os.getenv("LLM_PROVIDER", "openrouter") agent = make_agent( model_name, SubstitutionPairBatch, PROMPT, provider=provider, ) logger.info(f"Created agent: {provider}:{model_name}") return agent else: model_name = os.getenv("ANNOTATOR_MODEL") or os.getenv("OPENROUTER_MODEL") or "anthropic/claude-opus-4.5" provider = os.getenv("LLM_PROVIDER", "openrouter") agent = Agent( f"{provider}:{model_name}", output_type=SubstitutionPairBatch, system_prompt=PROMPT, ) logger.info(f"Created agent: {provider}:{model_name}") return agent except Exception as e: logger.error(f"Failed to create agent: {e}") return None def generate_test_aligned_pairs( test_set_path: Path, num_pairs_per_query: int = 2, max_queries: int = 50, batch_size: int = 10, ) -> list[dict[str, Any]]: """Generate substitution pairs aligned with test set queries.""" if not HAS_PYDANTIC_AI: logger.error("pydantic-ai required") return [] # Load test set try: test_set = load_test_set(test_set_path) queries = list(test_set.get("queries", {}).keys())[:max_queries] except Exception: # Fallback: load directly with open(test_set_path) as f: data = json.load(f) queries = list(data.get("queries", {}).keys())[:max_queries] logger.info(f"Generating substitution pairs for {len(queries)} test set queries...") agent = make_substitution_agent() if not agent: logger.error("Could not create agent") return [] all_pairs = [] # Generate pairs for each query for i, query in enumerate(queries, 1): if i % 10 == 0: logger.info(f" Processing query {i}/{len(queries)}...") prompt = f"Generate {num_pairs_per_query} substitution pairs for the card: {query}. Focus on cards that are functionally substitutable in competitive play." try: result = agent.run_sync(prompt) output = result.data if hasattr(result, 'data') else result.output if output and hasattr(output, 'pairs'): for pair in output.pairs: all_pairs.append({ "original": pair.original, "substitute": pair.substitute, "function": pair.function, "format": pair.format, "reasoning": pair.reasoning, "confidence": pair.confidence, "source_query": query, # Track which query this came from }) except Exception as e: logger.warning(f" Error generating pairs for {query}: {e}") continue logger.info(f"Generated {len(all_pairs)} pairs from {len(queries)} queries") return all_pairs def main() -> int: """Generate test-aligned substitution pairs.""" parser = argparse.ArgumentParser(description="Generate substitution pairs aligned with test set") parser.add_argument( "--test-set", type=Path, default=PATHS.test_magic, help="Test set path", ) parser.add_argument( "--pairs-per-query", type=int, default=2, help="Number of substitution pairs per query", ) parser.add_argument( "--max-queries", type=int, default=50, help="Maximum number of queries to process", ) parser.add_argument( "--output", type=Path, required=True, help="Output JSON file", ) args = parser.parse_args() if not HAS_PYDANTIC_AI: logger.error("pydantic-ai required: pip install pydantic-ai") return 1 pairs = generate_test_aligned_pairs( args.test_set, args.pairs_per_query, args.max_queries, ) if not pairs: logger.error("No pairs generated") return 1 # Save as list of [original, substitute] tuples output_pairs = [[p["original"], p["substitute"]] for p in pairs] args.output.parent.mkdir(parents=True, exist_ok=True) with open(args.output, "w") as f: json.dump(output_pairs, f, indent=2) logger.info(f" Generated {len(pairs)} pairs") logger.info(f" Saved to {args.output}") # Also save with metadata metadata_path = args.output.with_suffix('.metadata.json') with open(metadata_path, "w") as f: json.dump(pairs, f, indent=2) logger.info(f" Metadata saved to {metadata_path}") return 0 if __name__ == "__main__": import os import sys sys.exit(main())